Developing Krita Plugins

Krita is infinitely extensible with plugins. Tools, filters, large chunks
of the user interface and even colorspaces are plugins. In fact, Krita
recognizes these six types of plugins:

* colorspaces
* tools
* paint operations
* image filters
* viewplugins
* import/export filters

Krita itself consists of three layered libraries and a directory with
some common support classes.

KritaColor

The first library is kritacolor. This library loads the colorspace
plugins.  A colorspace plugin should implement the KisColorSpace abstract
class or, if the basic capabilities of the new colorspace will be
implemented by lcms, extend KisAbstractColorSpace. The kritacolor library
could be used from other applications and does not depend on KOffice.

KritaImage

The libkritaimage library loads the filter and paintop plugins and is
responsible for working with image data: changing pixels, compositing and
painting. Brushes, palettes, gradients and patterns are also loaded by
libkritaimage. It is our stated goal to make libkritaimage independent
of KOffice, but we currently share the gradient loading code with KOffice.

It is not easy at the moment to add new types of resources such as
brushes, palettes, gradients or patterns to Krita. Adding new brushes,
palettes, gradients and patterns is easy, of course. Krita follows
the guidelines of the Create project for these.

Krita filters must extend and implement the abstract class KisFilter,
KisFilterConfiguration and possibly KisFilterConfigurationWidget.
An example of a new filter could be Unsharp Mask.

Paint operations or paintops are the set of operations painting tools
suchs as freehand or circle have access to. Examples of paintops are pen,
airbrush or eraser. Paintops should extend the KisPaintop base class.
Examples of new paintops could be a chalk brush, an oilpaint brush
or a programmable brush.

KritaUI

The libkritaui library loads the tool and viewplugins. This library is
a KOffice Part, but also contains a number of widgets that are useful
for graphics applications. Maybe we will have to split this library in
kritapart and kritaui in the 2.0 release. For now, script writers are
not given access to this library and plugin writers are only allowed to
use this library when writing tools or viewplugins.

Tools are derived from KisTool or one of the specialized tool base
classes such as KisToolPaint, KisToolNonPaint or KisToolFreehand. A new
tool could be a foreground object selection tool. Painting tools (and
that includes tools that paint on the selection) can use any paintop to
determine the way pixels are changed.

Viewplugins are ordinary kparts that use kxmlgui to insinuate themselves
into Krita's user interface. Menu options, dialogs, toolbars -- any
kind of user interface extension can be a viewplugin. In fact, important
functionality like Krita's scripting support is written as a viewplugin.


Import/Export filters

Import/Export filters are KOffice filters, subclasses of KoFilter. Filters
read and write image data in any of the myriad image formats in existence.
And example of a new Krita import/export filter could be a PDF filter. Filters
are loaded by the KOffice libraries.

Creating plugins

Plugins are written in C++ and can use all of KDE and Qt and the Krita
developer API. Only viewplugins should use the KOffice API. If you do not
want to use C++, you can write scripts in Python or Ruby; that is a different
thing altogether, though, and you cannot write tools, colorspaces, paintops
or image filters as scripts.

Your distribution should have either installed the relevant header files with
Krita itself, or might have split the header files into either a KOffice dev or
a Krita dev package. You can find the api documentation for Krita's public
API at XXX.

Plugins are kde modules and should be tagged as such in their Makefile.am.
Filters, tools, paintops, colorspaces and import/export filters need .desktop
files; viewplugins need a kxmlgui .rc file in addition.


Colorspaces

Colorspaces implement the KisColorSpace pure virtual class. There are two
types of colorspaces: those that can use lcms for transformations between
colorspaces, and those that are too weird for lcms to handle. Examples of
the first are cmyk, rgb, yuv. An example of the latter is watercolor or
wet & sticky. Colorspaces that use lcms can be derived from KisAbstractColorSpace,
or of one of the base classes that are specialized for a certain number of bits
per channel.

Implementing a colorspace is pretty easy. The general principle is that
colorspaces work on a simple array of bytes. The interpretation of these
bytes is up to the colorspace. For instance, a pixel in 16-bit GrayA consists
of four bytes: two bytes for the gray value and two bytes for the alpha value.
You're free to use a struct to work with the memory layout of a pixel in your
colorspace implementation.

Filters and paintops make use of the rich set of methods offered by KisColorSpace
to do their work. In many cases, the default implementation in KisAbstractColorSpace
will work, but more slowly than a custom implementation in your own colorspace
because KisAbstractColorSpace will convert all pixels to 16-bit L*a*b and back.


Filters

Filters are plugins that examine the pixels in a layer and them make changes
to them. Although Krita uses an efficient tiled memory backend to store pixels,
filter writers do not have to bother with that. When writing a filter plugin
for the Java imaging api, Photoshop or the Gimp you need to take care of tile
edges and "cobble" tiles together.

Krita uses iterators to read and write pixel values. Alternatively, you can
read a block of pixels into a memory buffer, mess with it and then write it
back as a block. But that is not necessarily more efficient; it may just be
more convenient.

Krita images are composed of layers, of which there are four kinds: paint
layers, group layers, adjustment layers and part layers. Filters always operate
on paint layers. Paint layers contain paint devices, KisPaintDevice. A paint
device in its turn gives access to the actual pixels.

PaintDevices are generally passed around wrapped in shared pointers. A shared
pointer keeps track of in how many places the paint device is currently used
and deletes the paint device when it is no longer used anywhere. You recognize
the shared pointer version of a paint device through its SP suffix.

Let's examine a very simple filter, one that inverts every pixel. The code for
filter is in the koffice/krita/plugins/filters/exampe directory. The main method
is KisFilterInvert::process(KisPaintDeviceSP src, KisPaintDeviceSP dst,
KisFilterConfiguration* /*config*/, const QRect& rect).

The function gets passed two paint devices, a configuration object (which is not
used in this simple filter) and a rect. The rect describes the area of the paint
device which the filter should act on. This area is described by integers, which
means no sub-pixel accuracy.

The src paint device is for reading from, the dst paint device for writing to.
These parameters may point to the same actual paint device, or be two different
paint devices. (Note: this may change in the future


Paintops


Tools


Viewplugins


Import/Export filters
