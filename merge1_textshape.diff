diff --git a/libs/kotext/KoTextEditor.cpp b/libs/kotext/KoTextEditor.cpp
index 9f242e6..f6b592b 100644
--- a/libs/kotext/KoTextEditor.cpp
+++ b/libs/kotext/KoTextEditor.cpp
@@ -564,6 +564,7 @@ void KoTextEditor::bold(bool bold)
     d->caret.mergeCharFormat(format);
     registerTrackedChange(d->caret, KoGenChange::FormatChange, i18n("Bold"), format, prevFormat, false);
     d->updateState(KoTextEditor::Private::NoOp);
+    emit textFormatChanged();
 }
 
 void KoTextEditor::italic(bool italic)
@@ -580,6 +581,7 @@ void KoTextEditor::italic(bool italic)
     d->caret.mergeCharFormat(format);
     registerTrackedChange(d->caret, KoGenChange::FormatChange, i18n("Italic"), format, prevFormat, false);
     d->updateState(KoTextEditor::Private::NoOp);
+    emit textFormatChanged();
 }
 
 void KoTextEditor::underline(bool underline)
@@ -602,6 +604,7 @@ void KoTextEditor::underline(bool underline)
     d->caret.mergeCharFormat(format);
     registerTrackedChange(d->caret, KoGenChange::FormatChange, i18n("Underline"), format, prevFormat, false);
     d->updateState(KoTextEditor::Private::NoOp);
+    emit textFormatChanged();
 }
 
 void KoTextEditor::strikeOut(bool strikeout)
@@ -623,6 +626,7 @@ void KoTextEditor::strikeOut(bool strikeout)
     d->caret.mergeCharFormat(format);
     registerTrackedChange(d->caret, KoGenChange::FormatChange, i18n("Strike Out"), format, prevFormat, false);
     d->updateState(KoTextEditor::Private::NoOp);
+    emit textFormatChanged();
 }
 
 void KoTextEditor::setHorizontalTextAlignment(Qt::Alignment align)
@@ -645,6 +649,7 @@ void KoTextEditor::setHorizontalTextAlignment(Qt::Alignment align)
     d->updateState(KoTextEditor::Private::Format, i18n("Set Horizontal Alignment"));
     BlockFormatVisitor::visitSelection(this, aligner, i18n("Set Horizontal Alignment"));
     d->updateState(KoTextEditor::Private::NoOp);
+    emit textFormatChanged();
 }
 
 void KoTextEditor::setVerticalTextAlignment(Qt::Alignment align)
@@ -666,6 +671,7 @@ void KoTextEditor::setVerticalTextAlignment(Qt::Alignment align)
     d->caret.mergeCharFormat(format);
     registerTrackedChange(d->caret, KoGenChange::FormatChange, i18n("Set Vertical Alignment"), format, prevFormat, false);
     d->updateState(KoTextEditor::Private::NoOp);
+    emit textFormatChanged();
 }
 
 void KoTextEditor::decreaseIndent()
@@ -688,6 +694,7 @@ void KoTextEditor::decreaseIndent()
     d->updateState(KoTextEditor::Private::Format, i18n("Decrease Indent"));
     BlockFormatVisitor::visitSelection(this, indenter, i18n("Decrease Indent"));
     d->updateState(KoTextEditor::Private::NoOp);
+    emit textFormatChanged();
 }
 
 void KoTextEditor::increaseIndent()
@@ -710,6 +717,7 @@ void KoTextEditor::increaseIndent()
     d->updateState(KoTextEditor::Private::Format, i18n("Increase Indent"));
     BlockFormatVisitor::visitSelection(this, indenter, i18n("Increase Indent"));
     d->updateState(KoTextEditor::Private::NoOp);
+    emit textFormatChanged();
 }
 
 class FontResizer : public CharFormatVisitor
@@ -746,6 +754,7 @@ void KoTextEditor::decreaseFontSize()
     FontResizer sizer(FontResizer::Shrink);
     CharFormatVisitor::visitSelection(this, sizer, i18n("Decrease font size"));
     d->updateState(KoTextEditor::Private::NoOp);
+    emit textFormatChanged();
 }
 
 void KoTextEditor::increaseFontSize()
@@ -758,6 +767,7 @@ void KoTextEditor::increaseFontSize()
     FontResizer sizer(FontResizer::Grow);
     CharFormatVisitor::visitSelection(this, sizer, i18n("Increase font size"));
     d->updateState(KoTextEditor::Private::NoOp);
+    emit textFormatChanged();
 }
 
 void KoTextEditor::setFontFamily(const QString &font)
@@ -773,6 +783,7 @@ void KoTextEditor::setFontFamily(const QString &font)
     d->caret.mergeCharFormat(format);
     registerTrackedChange(d->caret, KoGenChange::FormatChange, i18n("Set Font"), format, prevFormat, false);
     d->updateState(KoTextEditor::Private::NoOp);
+    emit textFormatChanged();
 }
 
 void KoTextEditor::setFontSize(qreal size)
@@ -788,6 +799,7 @@ void KoTextEditor::setFontSize(qreal size)
     d->caret.mergeCharFormat(format);
     registerTrackedChange(d->caret, KoGenChange::FormatChange, i18n("Set Font Size"), format, prevFormat, false);
     d->updateState(KoTextEditor::Private::NoOp);
+    emit textFormatChanged();
 }
 
 void KoTextEditor::setTextBackgroundColor(const QColor &color)
@@ -803,6 +815,7 @@ void KoTextEditor::setTextBackgroundColor(const QColor &color)
     d->caret.mergeCharFormat(format);
     registerTrackedChange(d->caret, KoGenChange::FormatChange, i18n("Set Background Color"), format, prevFormat, false);
     d->updateState(KoTextEditor::Private::NoOp);
+    emit textFormatChanged();
 }
 
 void KoTextEditor::setTextColor(const QColor &color)
@@ -818,6 +831,7 @@ void KoTextEditor::setTextColor(const QColor &color)
     d->caret.mergeCharFormat(format);
     registerTrackedChange(d->caret, KoGenChange::FormatChange, i18n("Set Text Color"), format, prevFormat, false);
     d->updateState(KoTextEditor::Private::NoOp);
+    emit textFormatChanged();
 }
 
 void KoTextEditor::setStyle(KoCharacterStyle *style)
@@ -834,6 +848,7 @@ void KoTextEditor::setStyle(KoCharacterStyle *style)
     d->caret.setCharFormat(format);
     registerTrackedChange(d->caret, KoGenChange::FormatChange, i18n("Set Character Style"), format, prevFormat, false);
     d->updateState(KoTextEditor::Private::NoOp);
+    emit textFormatChanged();
 }
 
 void KoTextEditor::setStyle(KoParagraphStyle *style)
@@ -858,6 +873,7 @@ void KoTextEditor::setStyle(KoParagraphStyle *style)
         block = block.next();
     }
     d->updateState(KoTextEditor::Private::NoOp);
+    emit textFormatChanged();
 }
 
 void KoTextEditor::setDefaultFormat()
@@ -871,6 +887,7 @@ void KoTextEditor::setDefaultFormat()
         registerTrackedChange(d->caret, KoGenChange::FormatChange, i18n("Set default format"), format, prevFormat, false);
     }
     d->updateState(KoTextEditor::Private::NoOp);
+    emit textFormatChanged();
 }
 
 void KoTextEditor::addBookmark(const QString &name)
@@ -1201,6 +1218,7 @@ void KoTextEditor::toggleListNumbering(bool numberingEnabled)
     }
 
     addCommand(new ListItemNumberingCommand(block(), numberingEnabled));
+    emit textFormatChanged();
 }
 
 void KoTextEditor::setListProperties(KoListStyle::Style style,
@@ -1215,6 +1233,7 @@ void KoTextEditor::setListProperties(KoListStyle::Style style,
         flags = MergeWithAdjacentList;
     }
     addCommand(new ChangeListCommand(d->caret, style, level, flags));
+    emit textFormatChanged();
 }
 
 
@@ -1988,6 +2007,7 @@ void KoTextEditor::mergeBlockFormat(const QTextBlockFormat &modifier)
         return;
     }
     d->caret.mergeBlockFormat(modifier);
+    emit textFormatChanged();
 }
 
 void KoTextEditor::mergeCharFormat(const QTextCharFormat &modifier)
@@ -2187,6 +2207,7 @@ void KoTextEditor::setBlockFormat(const QTextBlockFormat &format)
 
     Q_UNUSED(format)
     d->caret.setBlockFormat(format);
+    emit textFormatChanged();
 }
 
 void KoTextEditor::setCharFormat(const QTextCharFormat &format)
@@ -2196,6 +2217,7 @@ void KoTextEditor::setCharFormat(const QTextCharFormat &format)
     }
 
     d->caret.setCharFormat(format);
+    emit textFormatChanged();
 }
 
 //void KoTextEditor::setTableFormat(const QTextTableFormat &format)
diff --git a/libs/kotext/KoTextEditor.h b/libs/kotext/KoTextEditor.h
index 94bf433..c1c1c5d 100644
--- a/libs/kotext/KoTextEditor.h
+++ b/libs/kotext/KoTextEditor.h
@@ -458,6 +458,7 @@ public slots:
 signals:
     void isBidiUpdated();
     void cursorPositionChanged();
+    void textFormatChanged();
 
 protected:
     bool recursiveProtectionCheck(QTextFrame::iterator it) const;
diff --git a/libs/kotext/styles/KoCharacterStyle.cpp b/libs/kotext/styles/KoCharacterStyle.cpp
index f9e0741..0b2c9b9 100644
--- a/libs/kotext/styles/KoCharacterStyle.cpp
+++ b/libs/kotext/styles/KoCharacterStyle.cpp
@@ -1802,6 +1802,11 @@ bool KoCharacterStyle::operator==(const KoCharacterStyle &other) const
      return compareCharacterProperties(other);
 }
 
+bool KoCharacterStyle::operator!=(const KoCharacterStyle &other) const
+{
+     return !compareCharacterProperties(other);
+}
+
 bool KoCharacterStyle::compareCharacterProperties(const KoCharacterStyle &other) const
 {
     return other.d->stylesPrivate == d->stylesPrivate;
@@ -2123,9 +2128,9 @@ QVariant KoCharacterStyle::value(int key) const
     QVariant variant = d->stylesPrivate.value(key);
     if (variant.isNull()) {
         if (d->parentStyle)
-            return d->parentStyle->value(key);
+            variant = d->parentStyle->value(key);
         else if (d->defaultStyle)
-            return d->defaultStyle->value(key);
+            variant = d->defaultStyle->value(key);
     }
     return variant;
 }
diff --git a/libs/kotext/styles/KoCharacterStyle.h b/libs/kotext/styles/KoCharacterStyle.h
index 898ba43..adbab83 100644
--- a/libs/kotext/styles/KoCharacterStyle.h
+++ b/libs/kotext/styles/KoCharacterStyle.h
@@ -467,6 +467,8 @@ public:
 
     bool operator==(const KoCharacterStyle &other) const;
 
+    bool operator!=(const KoCharacterStyle &other) const;
+
     /**
      * Removes properties from this style that have the same value in other style.
      */
diff --git a/libs/kotext/styles/KoParagraphStyle.h b/libs/kotext/styles/KoParagraphStyle.h
index 12ab672..2889609 100644
--- a/libs/kotext/styles/KoParagraphStyle.h
+++ b/libs/kotext/styles/KoParagraphStyle.h
@@ -61,6 +61,7 @@ class KOTEXT_EXPORT KoParagraphStyle : public KoCharacterStyle
     Q_OBJECT
 public:
     enum Property {
+        // Every 10 properties, the decimal number shown indicates the decimal offstet over the QTextFormat::UserProperty enum value
         StyleId = QTextFormat::UserProperty + 1,
         // Linespacing properties
         PercentLineHeight,  ///< this propery is used for a percentage of the highest character on that line
@@ -71,7 +72,7 @@ public:
         AlignLastLine,      ///< When the paragraph is justified, what to do with the last word line
         WidowThreshold,     ///< If 'keep together'=false, amount of lines to keep it anyway.
         OrphanThreshold,   ///< If 'keep together'=false, amount of lines to keep it anyway.
-        DropCaps,       ///< defines if a paragraph renders its first char(s) with drop-caps
+        DropCaps, /*10*/   ///< defines if a paragraph renders its first char(s) with drop-caps
         DropCapsLength, ///< Number of glyphs to show as drop-caps
         DropCapsLines,  ///< Number of lines that the drop-caps span
         DropCapsDistance,   ///< Distance between drop caps and text
@@ -83,7 +84,7 @@ public:
         HasTopBorder,   ///< If true, paint a border on the top
         HasRightBorder, ///< If true, paint a border on the right
         HasBottomBorder,///< If true, paint a border on the bottom
-        BorderLineWidth,///< Thickness of inner-border
+        BorderLineWidth, /*20*/ ///< Thickness of inner-border
         SecondBorderLineWidth,  ///< Thickness of outer-border
         DistanceToSecondBorder, ///< Distance between inner and outer border
         LeftPadding,    ///< distance between text and border
@@ -93,7 +94,7 @@ public:
         LeftBorderWidth,        ///< The thickness of the border, or 0 if there is no border
         LeftInnerBorderWidth,   ///< In case of style being 'double' the thickness of the inner border line
         LeftBorderSpacing,      ///< In case of style being 'double' the space between the inner and outer border lines
-        LeftBorderStyle,        ///< The border style. (see BorderStyle)
+        LeftBorderStyle, /*30*/ ///< The border style. (see BorderStyle)
         LeftBorderColor,        ///< The border Color
         TopBorderWidth,         ///< The thickness of the border, or 0 if there is no border
         TopInnerBorderWidth,    ///< In case of style being 'double' the thickness of the inner border line
@@ -103,7 +104,7 @@ public:
         RightBorderWidth,       ///< The thickness of the border, or 0 if there is no border
         RightInnerBorderWidth,  ///< In case of style being 'double' the thickness of the inner border line
         RightBorderSpacing,     ///< In case of style being 'double' the space between the inner and outer border lines
-        RightBorderStyle,       ///< The border style. (see BorderStyle)
+        RightBorderStyle, /*40*/ ///< The border style. (see BorderStyle)
         RightBorderColor,       ///< The border Color
         BottomBorderWidth,      ///< The thickness of the border, or 0 if there is no border
         BottomInnerBorderWidth, ///< In case of style being 'double' the thickness of the inner border line
@@ -115,7 +116,7 @@ public:
         ListStyleId,            ///< Style Id of associated list style
         ListStartValue,         ///< Int with the list-value that that parag will have. Ignored if this is not a list.
         RestartListNumbering,   ///< boolean to indicate that this paragraph will have numbering restart at the list-start. Ignored if this is not a list.
-        ListLevel,               ///< int with the list-level that the paragraph will get when this is a list (numbered paragraphs)
+        ListLevel, /*50*/       ///< int with the list-level that the paragraph will get when this is a list (numbered paragraphs)
         IsListHeader,           ///< bool, if true the paragraph shows up as a list item, but w/o a list label.
         UnnumberedListItem,     ///< bool. if true this paragraph is part of a list but is not numbered
 
@@ -133,7 +134,7 @@ public:
 
         // numbering
         LineNumbering,           ///< bool, specifies whether lines should be numbered in this paragraph
-        LineNumberStartValue,    ///< integer value that specifies the number for the first line in the paragraph
+        LineNumberStartValue, /*60*/ ///< integer value that specifies the number for the first line in the paragraph
         SectionStartings,            ///< list of section definitions
         SectionEndings,               ///< list <end of a named section>
 // do 15.5.24
diff --git a/libs/textlayout/CMakeLists.txt b/libs/textlayout/CMakeLists.txt
index af6d64a..3d9edfe 100644
--- a/libs/textlayout/CMakeLists.txt
+++ b/libs/textlayout/CMakeLists.txt
@@ -14,7 +14,6 @@ set(textlayout_LIB_SRCS
     KoTextLayoutRootAreaProvider.cpp
     KoTextDocumentLayout.cpp
     ListItemsHelper.cpp
-    KoStyleThumbnailer.cpp
     KoTextShapeContainerModel.cpp
     RunAroundHelper.cpp
     KoTextLayoutObstruction.cpp
@@ -28,6 +27,7 @@ set(textlayout_LIB_SRCS
     ToCGenerator.cpp
     DummyDocumentLayout.cpp
     IndexGeneratorManager.cpp
+    KoStyleThumbnailer.cpp
 )
 
 
@@ -48,11 +48,11 @@ install(TARGETS textlayout  ${INSTALL_TARGETS_DEFAULT_ARGS})
 install(
     FILES
     KoTextDocumentLayout.h
-    KoStyleThumbnailer.h
     KoTextLayoutArea.h
     KoTextLayoutRootArea.h
     KoTextShapeData.h
     KoPointedAt.h
+    KoStyleThumbnailer.h
     textlayout_export.h
     DESTINATION
     ${INCLUDE_INSTALL_DIR} COMPONENT Devel
diff --git a/libs/textlayout/FrameIterator.h b/libs/textlayout/FrameIterator.h
index c73d580..c1c5252 100644
--- a/libs/textlayout/FrameIterator.h
+++ b/libs/textlayout/FrameIterator.h
@@ -19,7 +19,6 @@
 #ifndef FRAMEITERATOR_H
 #define FRAMEITERATOR_H
 
-
 #include <QTextFrame>
 #include <QTextLine>
 #include <QTextTableCell>
diff --git a/libs/textlayout/KoStyleThumbnailer.cpp b/libs/textlayout/KoStyleThumbnailer.cpp
index 3529bbb..e1c1ca2 100644
--- a/libs/textlayout/KoStyleThumbnailer.cpp
+++ b/libs/textlayout/KoStyleThumbnailer.cpp
@@ -4,6 +4,7 @@
  * Copyright (C) 2007 Pierre Ducroquet <pinaraf@gmail.com>
  * Copyright (C) 2008 Girish Ramakrishnan <girish@forwardbias.in>
  * Copyright (C) 2009,2011 KO GmbH <cbo@kogmbh.com>
+ * Copyright (C) 2011-2012 Pierre Stirnweiss <pstirnweiss@googlemail.com>
  *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Library General Public
@@ -38,10 +39,10 @@
 
 #include <klocale.h>
 
+#include <QCache>
 #include <QFont>
+#include <QImage>
 #include <QPainter>
-#include <QPixmap>
-#include <QPixmapCache>
 #include <QRect>
 #include <QTextTable>
 #include <QTextTableFormat>
@@ -55,45 +56,52 @@
 class KoStyleThumbnailer::Private
 {
 public:
-    Private() : pixmapHelperDocument(0){ }
+    Private() :
+        thumbnailHelperDocument(new QTextDocument),
+        documentLayout(new KoTextDocumentLayout(thumbnailHelperDocument)),
+        defaultSize(QSize(250, 48))
+    {
+        thumbnailHelperDocument->setDocumentLayout(documentLayout);
+    }
+
+    ~Private()
+    {
+        delete documentLayout;
+        delete thumbnailHelperDocument;
+    }
 
-    QTextDocument *pixmapHelperDocument;
+    QTextDocument *thumbnailHelperDocument;
     KoTextDocumentLayout *documentLayout;
-    QPixmapCache pixmapCache; // cache of pixmap representations of the styles
+    QCache<QString, QImage> thumbnailCache; // cache of QImage representations of the styles
     QSize defaultSize;
 };
 
 KoStyleThumbnailer::KoStyleThumbnailer()
         : d(new Private())
 {
-    d->pixmapHelperDocument = new QTextDocument;
-    d->documentLayout = new KoTextDocumentLayout(d->pixmapHelperDocument);
-    d->pixmapHelperDocument->setDocumentLayout(d->documentLayout);
-    d->defaultSize = QSize(250, 48);
 }
 
 KoStyleThumbnailer::~KoStyleThumbnailer()
 {
-    delete d->documentLayout;
-    delete d->pixmapHelperDocument;
     delete d;
 }
 
-QPixmap KoStyleThumbnailer::thumbnail(KoParagraphStyle *style)
-{
-    return thumbnail(style, d->defaultSize);
-}
-
-QPixmap KoStyleThumbnailer::thumbnail(KoParagraphStyle *style, QSize size)
+QImage KoStyleThumbnailer::thumbnail(KoParagraphStyle *style, QSize size, bool recreateThumbnail)
 {
-    QString pixmapKey = "p_" + QString::number(style->styleId()) + "_" + QString::number(size.width()) + "_" + QString::number(size.height());
-    QPixmap pm(size.width(), size.height());
+    if (!style || style->name().isNull()) {
+        return QImage();
+    }
+    if (!size.isValid() || size.isNull()) {
+        size = d->defaultSize;
+    }
+    QString imageKey = "p_" + QString::number(style->styleId()) + "_" + QString::number(size.width()) + "_" + QString::number(size.height());
 
-    if (d->pixmapCache.find(pixmapKey, &pm)) {
-        return pm;
+    if (!recreateThumbnail && d->thumbnailCache.object(imageKey)) {
+        return QImage(*(d->thumbnailCache.object(imageKey)));
     }
 
-    pm.fill(Qt::transparent);
+    QImage *im = new QImage(size.width(), size.height(), QImage::Format_ARGB32_Premultiplied);
+    im->fill(QColor(Qt::transparent).rgba());
 
     KoParagraphStyle *clone = style->clone();
     //TODO: make the following real options
@@ -101,53 +109,60 @@ QPixmap KoStyleThumbnailer::thumbnail(KoParagraphStyle *style, QSize size)
     clone->setMargin(QTextLength(QTextLength::FixedLength, 0));
     clone->setPadding(0);
     //
-    QTextCursor cursor(d->pixmapHelperDocument);
+    QTextCursor cursor(d->thumbnailHelperDocument);
     cursor.select(QTextCursor::Document);
     cursor.setBlockFormat(QTextBlockFormat());
     cursor.setBlockCharFormat(QTextCharFormat());
     cursor.setCharFormat(QTextCharFormat());
-    cursor.insertText(clone->name());
     QTextBlock block = cursor.block();
     clone->applyStyle(block, true);
 
-    layoutThumbnail(size, pm);
+    KoCharacterStyle *charStyle = static_cast<KoCharacterStyle*>(clone);
+    QTextCharFormat format;
+    if (charStyle) {
+        charStyle->applyStyle(format);
+    }
+    cursor.insertText(clone->name(), format);
 
-    d->pixmapCache.insert(pixmapKey, pm);
-    delete clone;
-    return pm;
-}
+    layoutThumbnail(size, im);
 
-QPixmap KoStyleThumbnailer::thumbnail(KoCharacterStyle *style)
-{
-    return thumbnail(style, d->defaultSize);
+    d->thumbnailCache.insert(imageKey, im);
+    delete clone;
+    return QImage(*im);
 }
 
-QPixmap KoStyleThumbnailer::thumbnail(KoCharacterStyle *style, QSize size)
+QImage KoStyleThumbnailer::thumbnail(KoCharacterStyle *style, QSize size, bool recreateThumbnail)
 {
-    QString pixmapKey = "c_" + QString::number(style->styleId()) + "_" + QString::number(size.width()) + "_" + QString::number(size.height());
-    QPixmap pm(size.width(), size.height());
+    if (!style || style->name().isNull()) {
+        return QImage();
+    }
+    if (!size.isValid() || size.isNull()) {
+        size = d->defaultSize;
+    }
+    QString imageKey = "c_" + QString::number(style->styleId()) + "_" + QString::number(size.width()) + "_" + QString::number(size.height());
 
-    if (d->pixmapCache.find(pixmapKey, &pm)) {
-        return pm;
+    if (!recreateThumbnail && d->thumbnailCache.object(imageKey)) {
+        return QImage(*(d->thumbnailCache.object(imageKey)));
     }
 
-    pm.fill(Qt::transparent);
+    QImage *im = new QImage(size.width(), size.height(), QImage::Format_ARGB32_Premultiplied);
+    im->fill(QColor(Qt::transparent).rgba());
 
     KoCharacterStyle *clone = style->clone();
-    QTextCursor cursor(d->pixmapHelperDocument);
+    QTextCursor cursor(d->thumbnailHelperDocument);
+    QTextCharFormat format;
+    clone->applyStyle(format);
     cursor.select(QTextCursor::Document);
     cursor.setBlockFormat(QTextBlockFormat());
     cursor.setBlockCharFormat(QTextCharFormat());
     cursor.setCharFormat(QTextCharFormat());
-    cursor.insertText(clone->name());
-    QTextBlock block = cursor.block();
-    clone->applyStyle(block);
+    cursor.insertText(clone->name(), format);
 
-    layoutThumbnail(size, pm);
+    layoutThumbnail(size, im);
 
-    d->pixmapCache.insert(pixmapKey, pm);
+    d->thumbnailCache.insert(imageKey, im);
     delete clone;
-    return pm;
+    return QImage(*im);
 }
 
 void KoStyleThumbnailer::setThumbnailSize(QSize size)
@@ -155,21 +170,21 @@ void KoStyleThumbnailer::setThumbnailSize(QSize size)
     d->defaultSize = size;
 }
 
-void KoStyleThumbnailer::layoutThumbnail(QSize size, QPixmap &pm)
+void KoStyleThumbnailer::layoutThumbnail(QSize size, QImage *im)
 {
-    QPainter p(&pm);
+    QPainter p(im);
     d->documentLayout->removeRootArea();
     KoTextLayoutRootArea rootArea(d->documentLayout);
     rootArea.setReferenceRect(0, size.width(), 0, 1E6);
     rootArea.setNoWrap(1E6);
 
-    FrameIterator frameCursor(d->pixmapHelperDocument->rootFrame());
+    FrameIterator frameCursor(d->thumbnailHelperDocument->rootFrame());
     rootArea.layoutRoot(&frameCursor);
 
     QSizeF documentSize = rootArea.boundingRect().size();
     if (documentSize.width() > size.width() || documentSize.height() > size.height()) {
         //calculate the space needed for the font size indicator (should the preview big too big with the style's font size
-        QTextCursor cursor(d->pixmapHelperDocument);
+        QTextCursor cursor(d->thumbnailHelperDocument);
         cursor.select(QTextCursor::Document);
         QString sizeHint = "\t" + QString::number(cursor.charFormat().fontPointSize()) + "pt";
         p.save();
@@ -184,7 +199,7 @@ void KoStyleThumbnailer::layoutThumbnail(QSize size, QPixmap &pm)
         fmt.setFontPointSize((int)(fmt.fontPointSize()*reductionFactor));
         cursor.mergeCharFormat(fmt);
 
-        frameCursor = FrameIterator(d->pixmapHelperDocument->rootFrame());
+        frameCursor = FrameIterator(d->thumbnailHelperDocument->rootFrame());
         rootArea.setReferenceRect(0, size.width()-sizeHintRect.width(), 0, 1E6);
         rootArea.setNoWrap(1E6);
         rootArea.layoutRoot(&frameCursor);
diff --git a/libs/textlayout/KoStyleThumbnailer.h b/libs/textlayout/KoStyleThumbnailer.h
index 8645089..b3293c4 100644
--- a/libs/textlayout/KoStyleThumbnailer.h
+++ b/libs/textlayout/KoStyleThumbnailer.h
@@ -4,6 +4,7 @@
  * Copyright (C) 2008 Thorsten Zachmann <zachmann@kde.org>
  * Copyright (C) 2008 Girish Ramakrishnan <girish@forwardbias.in>
  * Copyright (C) 2009-2011 KO GmbH <cbo@kogmbh.com>
+ * Copyright (C) 2011-2012 Pierre Stirnweiss <pstirnweiss@googlemail.com>
  *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Library General Public
@@ -26,13 +27,14 @@
 
 #include "textlayout_export.h"
 
-#include <QPixmap>
+#include <QSize>
 
-class QSize;
-class QTextDocument;
 class KoCharacterStyle;
 class KoParagraphStyle;
 
+class QImage;
+class QTextDocument;
+
 /**
  * Helper class to create (and cache) thumbnails of styles
  */
@@ -50,33 +52,24 @@ public:
     virtual ~KoStyleThumbnailer();
 
     /**
-     * Return a thumbnail representing the style
-     * The thunbnail is the size specified with @fn setThumbnailSize or 250*48 pt if no size was provided.
-     * The created thumbnail is cached.
-     */
-    QPixmap thumbnail(KoParagraphStyle *style);
-
-    /**
      * @returns a thumbnail representing the @param style, constrained into the @param size.
+     * If there is no specified @param size, the thunbnail is the size specified with @fn setThumbnailSize or 250*48 pt if no size was provided.
      * If the given @param size is too small, the font size will be decreased, so the thumbnail fits.
      * The real font size is indicated in this case.
+     * If @param recreateThumbnail is true, do not return the cached thumbnail if it exist, but recreate a new one.
      * The created thumbnail is cached.
      */
-    QPixmap thumbnail(KoParagraphStyle *style, QSize size);
-
-    /**
-     * Return a thumbnail representing the style
-     * The thunbnail is the size specified with @fn setThumbnailSize or 250*48 pt if no size was provided.
-     * The created thumbnail is cached.
-     */
-    QPixmap thumbnail(KoCharacterStyle *style);
+    QImage thumbnail(KoParagraphStyle *style, QSize size = QSize(), bool recreateThumbnail = false);
 
     /**
      * @returns a thumbnail representing the @param style, constrained into the @param size.
+     * If there is no specified @param size, the thunbnail is the size specified with @fn setThumbnailSize or 250*48 pt if no size was provided.
      * If the given @param size is too small, the font size will be decreased, so the thumbnail fits.
      * The real font size is indicated in this case.
+     * If @param recreateThumbnail is true, do not return the cached thumbnail if it exist, but recreate a new one.
+     * The created thumbnail is cached.
      */
-    QPixmap thumbnail(KoCharacterStyle *style, QSize size);
+    QImage thumbnail(KoCharacterStyle *style, QSize size = QSize(), bool recreateThumbnail = false);
 
     /**
      * Sets the size of the thumbnails returned by the @fn thumbnail with no size arguments.
@@ -84,7 +77,7 @@ public:
     void setThumbnailSize(QSize size);
 
 private:
-    void layoutThumbnail(QSize size, QPixmap &pm);
+    void layoutThumbnail(QSize size, QImage *im);
 
     class Private;
     Private* const d;
diff --git a/merge_textshape.diff b/merge_textshape.diff
new file mode 100644
index 0000000..dda46ca
--- /dev/null
+++ b/merge_textshape.diff
@@ -0,0 +1,2680 @@
+diff --git a/libs/kotext/KoTextEditor.cpp b/libs/kotext/KoTextEditor.cpp
+index 9f242e6..f6b592b 100644
+--- a/libs/kotext/KoTextEditor.cpp
++++ b/libs/kotext/KoTextEditor.cpp
+@@ -564,6 +564,7 @@ void KoTextEditor::bold(bool bold)
+     d->caret.mergeCharFormat(format);
+     registerTrackedChange(d->caret, KoGenChange::FormatChange, i18n("Bold"), format, prevFormat, false);
+     d->updateState(KoTextEditor::Private::NoOp);
++    emit textFormatChanged();
+ }
+ 
+ void KoTextEditor::italic(bool italic)
+@@ -580,6 +581,7 @@ void KoTextEditor::italic(bool italic)
+     d->caret.mergeCharFormat(format);
+     registerTrackedChange(d->caret, KoGenChange::FormatChange, i18n("Italic"), format, prevFormat, false);
+     d->updateState(KoTextEditor::Private::NoOp);
++    emit textFormatChanged();
+ }
+ 
+ void KoTextEditor::underline(bool underline)
+@@ -602,6 +604,7 @@ void KoTextEditor::underline(bool underline)
+     d->caret.mergeCharFormat(format);
+     registerTrackedChange(d->caret, KoGenChange::FormatChange, i18n("Underline"), format, prevFormat, false);
+     d->updateState(KoTextEditor::Private::NoOp);
++    emit textFormatChanged();
+ }
+ 
+ void KoTextEditor::strikeOut(bool strikeout)
+@@ -623,6 +626,7 @@ void KoTextEditor::strikeOut(bool strikeout)
+     d->caret.mergeCharFormat(format);
+     registerTrackedChange(d->caret, KoGenChange::FormatChange, i18n("Strike Out"), format, prevFormat, false);
+     d->updateState(KoTextEditor::Private::NoOp);
++    emit textFormatChanged();
+ }
+ 
+ void KoTextEditor::setHorizontalTextAlignment(Qt::Alignment align)
+@@ -645,6 +649,7 @@ void KoTextEditor::setHorizontalTextAlignment(Qt::Alignment align)
+     d->updateState(KoTextEditor::Private::Format, i18n("Set Horizontal Alignment"));
+     BlockFormatVisitor::visitSelection(this, aligner, i18n("Set Horizontal Alignment"));
+     d->updateState(KoTextEditor::Private::NoOp);
++    emit textFormatChanged();
+ }
+ 
+ void KoTextEditor::setVerticalTextAlignment(Qt::Alignment align)
+@@ -666,6 +671,7 @@ void KoTextEditor::setVerticalTextAlignment(Qt::Alignment align)
+     d->caret.mergeCharFormat(format);
+     registerTrackedChange(d->caret, KoGenChange::FormatChange, i18n("Set Vertical Alignment"), format, prevFormat, false);
+     d->updateState(KoTextEditor::Private::NoOp);
++    emit textFormatChanged();
+ }
+ 
+ void KoTextEditor::decreaseIndent()
+@@ -688,6 +694,7 @@ void KoTextEditor::decreaseIndent()
+     d->updateState(KoTextEditor::Private::Format, i18n("Decrease Indent"));
+     BlockFormatVisitor::visitSelection(this, indenter, i18n("Decrease Indent"));
+     d->updateState(KoTextEditor::Private::NoOp);
++    emit textFormatChanged();
+ }
+ 
+ void KoTextEditor::increaseIndent()
+@@ -710,6 +717,7 @@ void KoTextEditor::increaseIndent()
+     d->updateState(KoTextEditor::Private::Format, i18n("Increase Indent"));
+     BlockFormatVisitor::visitSelection(this, indenter, i18n("Increase Indent"));
+     d->updateState(KoTextEditor::Private::NoOp);
++    emit textFormatChanged();
+ }
+ 
+ class FontResizer : public CharFormatVisitor
+@@ -746,6 +754,7 @@ void KoTextEditor::decreaseFontSize()
+     FontResizer sizer(FontResizer::Shrink);
+     CharFormatVisitor::visitSelection(this, sizer, i18n("Decrease font size"));
+     d->updateState(KoTextEditor::Private::NoOp);
++    emit textFormatChanged();
+ }
+ 
+ void KoTextEditor::increaseFontSize()
+@@ -758,6 +767,7 @@ void KoTextEditor::increaseFontSize()
+     FontResizer sizer(FontResizer::Grow);
+     CharFormatVisitor::visitSelection(this, sizer, i18n("Increase font size"));
+     d->updateState(KoTextEditor::Private::NoOp);
++    emit textFormatChanged();
+ }
+ 
+ void KoTextEditor::setFontFamily(const QString &font)
+@@ -773,6 +783,7 @@ void KoTextEditor::setFontFamily(const QString &font)
+     d->caret.mergeCharFormat(format);
+     registerTrackedChange(d->caret, KoGenChange::FormatChange, i18n("Set Font"), format, prevFormat, false);
+     d->updateState(KoTextEditor::Private::NoOp);
++    emit textFormatChanged();
+ }
+ 
+ void KoTextEditor::setFontSize(qreal size)
+@@ -788,6 +799,7 @@ void KoTextEditor::setFontSize(qreal size)
+     d->caret.mergeCharFormat(format);
+     registerTrackedChange(d->caret, KoGenChange::FormatChange, i18n("Set Font Size"), format, prevFormat, false);
+     d->updateState(KoTextEditor::Private::NoOp);
++    emit textFormatChanged();
+ }
+ 
+ void KoTextEditor::setTextBackgroundColor(const QColor &color)
+@@ -803,6 +815,7 @@ void KoTextEditor::setTextBackgroundColor(const QColor &color)
+     d->caret.mergeCharFormat(format);
+     registerTrackedChange(d->caret, KoGenChange::FormatChange, i18n("Set Background Color"), format, prevFormat, false);
+     d->updateState(KoTextEditor::Private::NoOp);
++    emit textFormatChanged();
+ }
+ 
+ void KoTextEditor::setTextColor(const QColor &color)
+@@ -818,6 +831,7 @@ void KoTextEditor::setTextColor(const QColor &color)
+     d->caret.mergeCharFormat(format);
+     registerTrackedChange(d->caret, KoGenChange::FormatChange, i18n("Set Text Color"), format, prevFormat, false);
+     d->updateState(KoTextEditor::Private::NoOp);
++    emit textFormatChanged();
+ }
+ 
+ void KoTextEditor::setStyle(KoCharacterStyle *style)
+@@ -834,6 +848,7 @@ void KoTextEditor::setStyle(KoCharacterStyle *style)
+     d->caret.setCharFormat(format);
+     registerTrackedChange(d->caret, KoGenChange::FormatChange, i18n("Set Character Style"), format, prevFormat, false);
+     d->updateState(KoTextEditor::Private::NoOp);
++    emit textFormatChanged();
+ }
+ 
+ void KoTextEditor::setStyle(KoParagraphStyle *style)
+@@ -858,6 +873,7 @@ void KoTextEditor::setStyle(KoParagraphStyle *style)
+         block = block.next();
+     }
+     d->updateState(KoTextEditor::Private::NoOp);
++    emit textFormatChanged();
+ }
+ 
+ void KoTextEditor::setDefaultFormat()
+@@ -871,6 +887,7 @@ void KoTextEditor::setDefaultFormat()
+         registerTrackedChange(d->caret, KoGenChange::FormatChange, i18n("Set default format"), format, prevFormat, false);
+     }
+     d->updateState(KoTextEditor::Private::NoOp);
++    emit textFormatChanged();
+ }
+ 
+ void KoTextEditor::addBookmark(const QString &name)
+@@ -1201,6 +1218,7 @@ void KoTextEditor::toggleListNumbering(bool numberingEnabled)
+     }
+ 
+     addCommand(new ListItemNumberingCommand(block(), numberingEnabled));
++    emit textFormatChanged();
+ }
+ 
+ void KoTextEditor::setListProperties(KoListStyle::Style style,
+@@ -1215,6 +1233,7 @@ void KoTextEditor::setListProperties(KoListStyle::Style style,
+         flags = MergeWithAdjacentList;
+     }
+     addCommand(new ChangeListCommand(d->caret, style, level, flags));
++    emit textFormatChanged();
+ }
+ 
+ 
+@@ -1988,6 +2007,7 @@ void KoTextEditor::mergeBlockFormat(const QTextBlockFormat &modifier)
+         return;
+     }
+     d->caret.mergeBlockFormat(modifier);
++    emit textFormatChanged();
+ }
+ 
+ void KoTextEditor::mergeCharFormat(const QTextCharFormat &modifier)
+@@ -2187,6 +2207,7 @@ void KoTextEditor::setBlockFormat(const QTextBlockFormat &format)
+ 
+     Q_UNUSED(format)
+     d->caret.setBlockFormat(format);
++    emit textFormatChanged();
+ }
+ 
+ void KoTextEditor::setCharFormat(const QTextCharFormat &format)
+@@ -2196,6 +2217,7 @@ void KoTextEditor::setCharFormat(const QTextCharFormat &format)
+     }
+ 
+     d->caret.setCharFormat(format);
++    emit textFormatChanged();
+ }
+ 
+ //void KoTextEditor::setTableFormat(const QTextTableFormat &format)
+diff --git a/libs/kotext/KoTextEditor.h b/libs/kotext/KoTextEditor.h
+index 94bf433..c1c1c5d 100644
+--- a/libs/kotext/KoTextEditor.h
++++ b/libs/kotext/KoTextEditor.h
+@@ -458,6 +458,7 @@ public slots:
+ signals:
+     void isBidiUpdated();
+     void cursorPositionChanged();
++    void textFormatChanged();
+ 
+ protected:
+     bool recursiveProtectionCheck(QTextFrame::iterator it) const;
+diff --git a/libs/kotext/styles/KoCharacterStyle.cpp b/libs/kotext/styles/KoCharacterStyle.cpp
+index f9e0741..adbbd04 100644
+--- a/libs/kotext/styles/KoCharacterStyle.cpp
++++ b/libs/kotext/styles/KoCharacterStyle.cpp
+@@ -2123,10 +2123,13 @@ QVariant KoCharacterStyle::value(int key) const
+     QVariant variant = d->stylesPrivate.value(key);
+     if (variant.isNull()) {
+         if (d->parentStyle)
+-            return d->parentStyle->value(key);
++            variant = d->parentStyle->value(key);
+         else if (d->defaultStyle)
+-            return d->defaultStyle->value(key);
++            variant = d->defaultStyle->value(key);
+     }
++    if (variant.isNull() && d->hardCodedDefaultStyle.contains(key))
++        variant = d->hardCodedDefaultStyle.value(key);
++
+     return variant;
+ }
+ 
+diff --git a/libs/kotext/styles/KoParagraphStyle.h b/libs/kotext/styles/KoParagraphStyle.h
+index 12ab672..beb78d1 100644
+--- a/libs/kotext/styles/KoParagraphStyle.h
++++ b/libs/kotext/styles/KoParagraphStyle.h
+@@ -83,7 +83,7 @@ public:
+         HasTopBorder,   ///< If true, paint a border on the top
+         HasRightBorder, ///< If true, paint a border on the right
+         HasBottomBorder,///< If true, paint a border on the bottom
+-        BorderLineWidth,///< Thickness of inner-border
++        BorderLineWidth,///< Thickness of inner-border                  20
+         SecondBorderLineWidth,  ///< Thickness of outer-border
+         DistanceToSecondBorder, ///< Distance between inner and outer border
+         LeftPadding,    ///< distance between text and border
+@@ -93,7 +93,7 @@ public:
+         LeftBorderWidth,        ///< The thickness of the border, or 0 if there is no border
+         LeftInnerBorderWidth,   ///< In case of style being 'double' the thickness of the inner border line
+         LeftBorderSpacing,      ///< In case of style being 'double' the space between the inner and outer border lines
+-        LeftBorderStyle,        ///< The border style. (see BorderStyle)
++        LeftBorderStyle,        ///< 30 The border style. (see BorderStyle)
+         LeftBorderColor,        ///< The border Color
+         TopBorderWidth,         ///< The thickness of the border, or 0 if there is no border
+         TopInnerBorderWidth,    ///< In case of style being 'double' the thickness of the inner border line
+@@ -103,7 +103,7 @@ public:
+         RightBorderWidth,       ///< The thickness of the border, or 0 if there is no border
+         RightInnerBorderWidth,  ///< In case of style being 'double' the thickness of the inner border line
+         RightBorderSpacing,     ///< In case of style being 'double' the space between the inner and outer border lines
+-        RightBorderStyle,       ///< The border style. (see BorderStyle)
++        RightBorderStyle,       ///< 40 The border style. (see BorderStyle)
+         RightBorderColor,       ///< The border Color
+         BottomBorderWidth,      ///< The thickness of the border, or 0 if there is no border
+         BottomInnerBorderWidth, ///< In case of style being 'double' the thickness of the inner border line
+@@ -115,7 +115,7 @@ public:
+         ListStyleId,            ///< Style Id of associated list style
+         ListStartValue,         ///< Int with the list-value that that parag will have. Ignored if this is not a list.
+         RestartListNumbering,   ///< boolean to indicate that this paragraph will have numbering restart at the list-start. Ignored if this is not a list.
+-        ListLevel,               ///< int with the list-level that the paragraph will get when this is a list (numbered paragraphs)
++        ListLevel,               ///< 50 int with the list-level that the paragraph will get when this is a list (numbered paragraphs)
+         IsListHeader,           ///< bool, if true the paragraph shows up as a list item, but w/o a list label.
+         UnnumberedListItem,     ///< bool. if true this paragraph is part of a list but is not numbered
+ 
+@@ -133,7 +133,7 @@ public:
+ 
+         // numbering
+         LineNumbering,           ///< bool, specifies whether lines should be numbered in this paragraph
+-        LineNumberStartValue,    ///< integer value that specifies the number for the first line in the paragraph
++        LineNumberStartValue,    ///< 60 integer value that specifies the number for the first line in the paragraph
+         SectionStartings,            ///< list of section definitions
+         SectionEndings,               ///< list <end of a named section>
+ // do 15.5.24
+diff --git a/libs/textlayout/CMakeLists.txt b/libs/textlayout/CMakeLists.txt
+index af6d64a..3d9edfe 100644
+--- a/libs/textlayout/CMakeLists.txt
++++ b/libs/textlayout/CMakeLists.txt
+@@ -14,7 +14,6 @@ set(textlayout_LIB_SRCS
+     KoTextLayoutRootAreaProvider.cpp
+     KoTextDocumentLayout.cpp
+     ListItemsHelper.cpp
+-    KoStyleThumbnailer.cpp
+     KoTextShapeContainerModel.cpp
+     RunAroundHelper.cpp
+     KoTextLayoutObstruction.cpp
+@@ -28,6 +27,7 @@ set(textlayout_LIB_SRCS
+     ToCGenerator.cpp
+     DummyDocumentLayout.cpp
+     IndexGeneratorManager.cpp
++    KoStyleThumbnailer.cpp
+ )
+ 
+ 
+@@ -48,11 +48,11 @@ install(TARGETS textlayout  ${INSTALL_TARGETS_DEFAULT_ARGS})
+ install(
+     FILES
+     KoTextDocumentLayout.h
+-    KoStyleThumbnailer.h
+     KoTextLayoutArea.h
+     KoTextLayoutRootArea.h
+     KoTextShapeData.h
+     KoPointedAt.h
++    KoStyleThumbnailer.h
+     textlayout_export.h
+     DESTINATION
+     ${INCLUDE_INSTALL_DIR} COMPONENT Devel
+diff --git a/libs/textlayout/FrameIterator.h b/libs/textlayout/FrameIterator.h
+index c73d580..c1c5252 100644
+--- a/libs/textlayout/FrameIterator.h
++++ b/libs/textlayout/FrameIterator.h
+@@ -19,7 +19,6 @@
+ #ifndef FRAMEITERATOR_H
+ #define FRAMEITERATOR_H
+ 
+-
+ #include <QTextFrame>
+ #include <QTextLine>
+ #include <QTextTableCell>
+diff --git a/libs/textlayout/KoStyleThumbnailer.cpp b/libs/textlayout/KoStyleThumbnailer.cpp
+index 3529bbb..3920b9b 100644
+--- a/libs/textlayout/KoStyleThumbnailer.cpp
++++ b/libs/textlayout/KoStyleThumbnailer.cpp
+@@ -4,6 +4,7 @@
+  * Copyright (C) 2007 Pierre Ducroquet <pinaraf@gmail.com>
+  * Copyright (C) 2008 Girish Ramakrishnan <girish@forwardbias.in>
+  * Copyright (C) 2009,2011 KO GmbH <cbo@kogmbh.com>
++ * Copyright (C) 2011-2012 Pierre Stirnweiss <pstirnweiss@googlemail.com>
+  *
+  * This library is free software; you can redistribute it and/or
+  * modify it under the terms of the GNU Library General Public
+@@ -38,10 +39,10 @@
+ 
+ #include <klocale.h>
+ 
++#include <QCache>
+ #include <QFont>
++#include <QImage>
+ #include <QPainter>
+-#include <QPixmap>
+-#include <QPixmapCache>
+ #include <QRect>
+ #include <QTextTable>
+ #include <QTextTableFormat>
+@@ -55,45 +56,51 @@
+ class KoStyleThumbnailer::Private
+ {
+ public:
+-    Private() : pixmapHelperDocument(0){ }
++    Private() : thumbnailHelperDocument(0){ }
+ 
+-    QTextDocument *pixmapHelperDocument;
++    QTextDocument *thumbnailHelperDocument;
+     KoTextDocumentLayout *documentLayout;
+-    QPixmapCache pixmapCache; // cache of pixmap representations of the styles
++    QCache<QString, QImage> thumbnailCache; // cache of QImage representations of the styles
+     QSize defaultSize;
+ };
+ 
+ KoStyleThumbnailer::KoStyleThumbnailer()
+         : d(new Private())
+ {
+-    d->pixmapHelperDocument = new QTextDocument;
+-    d->documentLayout = new KoTextDocumentLayout(d->pixmapHelperDocument);
+-    d->pixmapHelperDocument->setDocumentLayout(d->documentLayout);
++    d->thumbnailHelperDocument = new QTextDocument;
++    d->documentLayout = new KoTextDocumentLayout(d->thumbnailHelperDocument);
++    d->thumbnailHelperDocument->setDocumentLayout(d->documentLayout);
+     d->defaultSize = QSize(250, 48);
+ }
+ 
+ KoStyleThumbnailer::~KoStyleThumbnailer()
+ {
+     delete d->documentLayout;
+-    delete d->pixmapHelperDocument;
++    delete d->thumbnailHelperDocument;
+     delete d;
+ }
+ 
+-QPixmap KoStyleThumbnailer::thumbnail(KoParagraphStyle *style)
++QImage KoStyleThumbnailer::thumbnail(KoParagraphStyle *style, bool dirtyCache)
+ {
+-    return thumbnail(style, d->defaultSize);
++    return thumbnail(style, d->defaultSize, dirtyCache);
+ }
+ 
+-QPixmap KoStyleThumbnailer::thumbnail(KoParagraphStyle *style, QSize size)
++QImage KoStyleThumbnailer::thumbnail(KoParagraphStyle *style, QSize size, bool dirtyCache)
+ {
+-    QString pixmapKey = "p_" + QString::number(style->styleId()) + "_" + QString::number(size.width()) + "_" + QString::number(size.height());
+-    QPixmap pm(size.width(), size.height());
++    if (!style || style->name().isNull()) {
++        return QImage();
++    }
++    if (size.isNull()) {
++        size = d->defaultSize;
++    }
++    QString imageKey = "p_" + QString::number(style->styleId()) + "_" + QString::number(size.width()) + "_" + QString::number(size.height());
+ 
+-    if (d->pixmapCache.find(pixmapKey, &pm)) {
+-        return pm;
++    if (d->thumbnailCache.object(imageKey) && !dirtyCache) {
++        return QImage(*(d->thumbnailCache.object(imageKey)));
+     }
+ 
+-    pm.fill(Qt::transparent);
++    QImage *im = new QImage(size.width(), size.height(), QImage::Format_ARGB32_Premultiplied);
++    im->fill(Qt::transparent);
+ 
+     KoParagraphStyle *clone = style->clone();
+     //TODO: make the following real options
+@@ -101,53 +108,65 @@ QPixmap KoStyleThumbnailer::thumbnail(KoParagraphStyle *style, QSize size)
+     clone->setMargin(QTextLength(QTextLength::FixedLength, 0));
+     clone->setPadding(0);
+     //
+-    QTextCursor cursor(d->pixmapHelperDocument);
++    QTextCursor cursor(d->thumbnailHelperDocument);
+     cursor.select(QTextCursor::Document);
+     cursor.setBlockFormat(QTextBlockFormat());
+     cursor.setBlockCharFormat(QTextCharFormat());
+     cursor.setCharFormat(QTextCharFormat());
+-    cursor.insertText(clone->name());
+     QTextBlock block = cursor.block();
+     clone->applyStyle(block, true);
+ 
+-    layoutThumbnail(size, pm);
++    KoCharacterStyle *charStyle = static_cast<KoCharacterStyle*>(clone);
++    QTextCharFormat format;
++    if (charStyle) {
++        charStyle->applyStyle(format);
++    }
++    cursor.insertText(clone->name(), format);
++
++    layoutThumbnail(size, im);
+ 
+-    d->pixmapCache.insert(pixmapKey, pm);
++    d->thumbnailCache.insert(imageKey, im);
+     delete clone;
+-    return pm;
++    return QImage(*im);
+ }
+ 
+-QPixmap KoStyleThumbnailer::thumbnail(KoCharacterStyle *style)
++QImage KoStyleThumbnailer::thumbnail(KoCharacterStyle *style, bool dirtyCache)
+ {
+-    return thumbnail(style, d->defaultSize);
++    return thumbnail(style, d->defaultSize, dirtyCache);
+ }
+ 
+-QPixmap KoStyleThumbnailer::thumbnail(KoCharacterStyle *style, QSize size)
++QImage KoStyleThumbnailer::thumbnail(KoCharacterStyle *style, QSize size, bool dirtyCache)
+ {
+-    QString pixmapKey = "c_" + QString::number(style->styleId()) + "_" + QString::number(size.width()) + "_" + QString::number(size.height());
+-    QPixmap pm(size.width(), size.height());
++    if (!style || style->name().isNull()) {
++        return QImage();
++    }
++    if (size.isNull()) {
++        size = d->defaultSize;
++    }
++    QString imageKey = "c_" + QString::number(style->styleId()) + "_" + QString::number(size.width()) + "_" + QString::number(size.height());
+ 
+-    if (d->pixmapCache.find(pixmapKey, &pm)) {
+-        return pm;
++    if (d->thumbnailCache.object(imageKey) && !dirtyCache) {
++        return QImage(*(d->thumbnailCache.object(imageKey)));
+     }
+ 
+-    pm.fill(Qt::transparent);
++    QImage *im = new QImage(size.width(), size.height(), QImage::Format_ARGB32_Premultiplied);
++    im->fill(Qt::transparent);
+ 
+     KoCharacterStyle *clone = style->clone();
+-    QTextCursor cursor(d->pixmapHelperDocument);
++    QTextCursor cursor(d->thumbnailHelperDocument);
++    QTextCharFormat format;
++    clone->applyStyle(format);
+     cursor.select(QTextCursor::Document);
+     cursor.setBlockFormat(QTextBlockFormat());
+     cursor.setBlockCharFormat(QTextCharFormat());
+     cursor.setCharFormat(QTextCharFormat());
+-    cursor.insertText(clone->name());
+-    QTextBlock block = cursor.block();
+-    clone->applyStyle(block);
++    cursor.insertText(clone->name(), format);
+ 
+-    layoutThumbnail(size, pm);
++    layoutThumbnail(size, im);
+ 
+-    d->pixmapCache.insert(pixmapKey, pm);
++    d->thumbnailCache.insert(imageKey, im);
+     delete clone;
+-    return pm;
++    return QImage(*im);
+ }
+ 
+ void KoStyleThumbnailer::setThumbnailSize(QSize size)
+@@ -155,21 +174,21 @@ void KoStyleThumbnailer::setThumbnailSize(QSize size)
+     d->defaultSize = size;
+ }
+ 
+-void KoStyleThumbnailer::layoutThumbnail(QSize size, QPixmap &pm)
++void KoStyleThumbnailer::layoutThumbnail(QSize size, QImage *im)
+ {
+-    QPainter p(&pm);
++    QPainter p(im);
+     d->documentLayout->removeRootArea();
+     KoTextLayoutRootArea rootArea(d->documentLayout);
+     rootArea.setReferenceRect(0, size.width(), 0, 1E6);
+     rootArea.setNoWrap(1E6);
+ 
+-    FrameIterator frameCursor(d->pixmapHelperDocument->rootFrame());
++    FrameIterator frameCursor(d->thumbnailHelperDocument->rootFrame());
+     rootArea.layoutRoot(&frameCursor);
+ 
+     QSizeF documentSize = rootArea.boundingRect().size();
+     if (documentSize.width() > size.width() || documentSize.height() > size.height()) {
+         //calculate the space needed for the font size indicator (should the preview big too big with the style's font size
+-        QTextCursor cursor(d->pixmapHelperDocument);
++        QTextCursor cursor(d->thumbnailHelperDocument);
+         cursor.select(QTextCursor::Document);
+         QString sizeHint = "\t" + QString::number(cursor.charFormat().fontPointSize()) + "pt";
+         p.save();
+@@ -184,7 +203,7 @@ void KoStyleThumbnailer::layoutThumbnail(QSize size, QPixmap &pm)
+         fmt.setFontPointSize((int)(fmt.fontPointSize()*reductionFactor));
+         cursor.mergeCharFormat(fmt);
+ 
+-        frameCursor = FrameIterator(d->pixmapHelperDocument->rootFrame());
++        frameCursor = FrameIterator(d->thumbnailHelperDocument->rootFrame());
+         rootArea.setReferenceRect(0, size.width()-sizeHintRect.width(), 0, 1E6);
+         rootArea.setNoWrap(1E6);
+         rootArea.layoutRoot(&frameCursor);
+diff --git a/libs/textlayout/KoStyleThumbnailer.h b/libs/textlayout/KoStyleThumbnailer.h
+index 8645089..2d4722a 100644
+--- a/libs/textlayout/KoStyleThumbnailer.h
++++ b/libs/textlayout/KoStyleThumbnailer.h
+@@ -4,6 +4,7 @@
+  * Copyright (C) 2008 Thorsten Zachmann <zachmann@kde.org>
+  * Copyright (C) 2008 Girish Ramakrishnan <girish@forwardbias.in>
+  * Copyright (C) 2009-2011 KO GmbH <cbo@kogmbh.com>
++ * Copyright (C) 2011-2012 Pierre Stirnweiss <pstirnweiss@googlemail.com>
+  *
+  * This library is free software; you can redistribute it and/or
+  * modify it under the terms of the GNU Library General Public
+@@ -26,12 +27,12 @@
+ 
+ #include "textlayout_export.h"
+ 
+-#include <QPixmap>
++class KoCharacterStyle;
++class KoParagraphStyle;
+ 
++class QImage;
+ class QSize;
+ class QTextDocument;
+-class KoCharacterStyle;
+-class KoParagraphStyle;
+ 
+ /**
+  * Helper class to create (and cache) thumbnails of styles
+@@ -52,31 +53,36 @@ public:
+     /**
+      * Return a thumbnail representing the style
+      * The thunbnail is the size specified with @fn setThumbnailSize or 250*48 pt if no size was provided.
++     * If @param dirtyCache is true, do not return the cached thumbnail if it exist, but recreate a new one.
+      * The created thumbnail is cached.
+      */
+-    QPixmap thumbnail(KoParagraphStyle *style);
++    QImage thumbnail(KoParagraphStyle *style, bool dirtyCache = false);
+ 
+     /**
+      * @returns a thumbnail representing the @param style, constrained into the @param size.
+      * If the given @param size is too small, the font size will be decreased, so the thumbnail fits.
+      * The real font size is indicated in this case.
++     * If @param dirtyCache is true, do not return the cached thumbnail if it exist, but recreate a new one.
+      * The created thumbnail is cached.
+      */
+-    QPixmap thumbnail(KoParagraphStyle *style, QSize size);
++    QImage thumbnail(KoParagraphStyle *style, QSize size, bool dirtyCache = false);
+ 
+     /**
+      * Return a thumbnail representing the style
+      * The thunbnail is the size specified with @fn setThumbnailSize or 250*48 pt if no size was provided.
++     * If @param dirtyCache is true, do not return the cached thumbnail if it exist, but recreate a new one.
+      * The created thumbnail is cached.
+      */
+-    QPixmap thumbnail(KoCharacterStyle *style);
++    QImage thumbnail(KoCharacterStyle *style, bool dirtyCache = false);
+ 
+     /**
+      * @returns a thumbnail representing the @param style, constrained into the @param size.
+      * If the given @param size is too small, the font size will be decreased, so the thumbnail fits.
+      * The real font size is indicated in this case.
++     * If @param dirtyCache is true, do not return the cached thumbnail if it exist, but recreate a new one.
++     * The created thumbnail is cached.
+      */
+-    QPixmap thumbnail(KoCharacterStyle *style, QSize size);
++    QImage thumbnail(KoCharacterStyle *style, QSize size, bool dirtyCache = false);
+ 
+     /**
+      * Sets the size of the thumbnails returned by the @fn thumbnail with no size arguments.
+@@ -84,7 +90,7 @@ public:
+     void setThumbnailSize(QSize size);
+ 
+ private:
+-    void layoutThumbnail(QSize size, QPixmap &pm);
++    void layoutThumbnail(QSize size, QImage *im);
+ 
+     class Private;
+     Private* const d;
+diff --git a/plugins/textshape/CMakeLists.txt b/plugins/textshape/CMakeLists.txt
+index fad7c04..60979db 100644
+--- a/plugins/textshape/CMakeLists.txt
++++ b/plugins/textshape/CMakeLists.txt
+@@ -35,6 +35,8 @@ SET ( textshape_SRCS
+ 
+     dialogs/StylesWidget.cpp
+     dialogs/SpecialButton.cpp
++    dialogs/StylesCombo.cpp
++    dialogs/StylesComboPreview.cpp
+     dialogs/SimpleCharacterWidget.cpp
+     dialogs/SimpleParagraphWidget.cpp
+     dialogs/SimpleTableWidget.cpp
+diff --git a/plugins/textshape/TextTool.cpp b/plugins/textshape/TextTool.cpp
+index f6822bd..78b5fd5 100644
+--- a/plugins/textshape/TextTool.cpp
++++ b/plugins/textshape/TextTool.cpp
+@@ -2,7 +2,7 @@
+  * Copyright (C) 2006-2010 Thomas Zander <zander@kde.org>
+  * Copyright (C) 2008 Thorsten Zachmann <zachmann@kde.org>
+  * Copyright (C) 2008 Girish Ramakrishnan <girish@forwardbias.in>
+- * Copyright (C) 2008 Pierre Stirnweiss <pierre.stirnweiss_calligra@gadz.org>
++ * Copyright (C) 2008, 2012 Pierre Stirnweiss <pstirnweiss@googlemail.org>
+  * Copyright (C) 2009 KO GmbH <cbo@kogmbh.com>
+  * Copyright (C) 2011 Mojtaba Shahi Senobari <mojtaba.shahi3000@gmail.com>
+  *
+@@ -818,6 +818,7 @@ void TextTool::setShapeData(KoTextShapeData *data)
+     if (docChanged) {
+         if (!m_textEditor.isNull()) {
+             disconnect(m_textEditor.data(), SIGNAL(isBidiUpdated()), this, SLOT(isBidiUpdated()));
++            disconnect(m_textEditor.data(), SIGNAL(textFormatChanged()), this, SLOT(updateActions()));
+         }
+         m_textEditor = KoTextDocument(m_textShapeData->document()).textEditor();
+         Q_ASSERT(m_textEditor.data());
+@@ -835,6 +836,7 @@ void TextTool::setShapeData(KoTextShapeData *data)
+         }
+ 
+         connect(m_textEditor.data(), SIGNAL(isBidiUpdated()), this, SLOT(isBidiUpdated()));
++        connect(m_textEditor.data(), SIGNAL(textFormatChanged()), this, SLOT(updateActions()));
+     }
+     m_textEditor.data()->updateDefaultTextDirection(m_textShapeData->pageDirection());
+ }
+@@ -1394,6 +1396,7 @@ void TextTool::updateActions()
+ 
+     m_allowActions = true;
+ 
++    ///TODO if selection contains several different format
+     emit charFormatChanged(cf);
+     emit blockFormatChanged(bf);
+     emit blockChanged(textEditor->block());
+@@ -1441,10 +1444,10 @@ void TextTool::activate(ToolActivation toolActivation, const QSet<KoShape*> &sha
+     setShapeData(static_cast<KoTextShapeData*>(m_textShape->userData()));
+     useCursor(Qt::IBeamCursor);
+ 
++    updateStyleManager();
+     repaintSelection();
+     updateSelectionHandler();
+     updateActions();
+-    updateStyleManager();
+     if (m_specialCharacterDocker)
+         m_specialCharacterDocker->setEnabled(true);
+     readConfig();
+@@ -1592,8 +1595,11 @@ QList<QWidget *> TextTool::createOptionWidgets()
+     // Connect to/with simple character widget (docker)
+     connect(this, SIGNAL(styleManagerChanged(KoStyleManager *)), scw, SLOT(setStyleManager(KoStyleManager *)));
+     connect(this, SIGNAL(charFormatChanged(QTextCharFormat)), scw, SLOT(setCurrentFormat(QTextCharFormat)));
++    connect(this, SIGNAL(blockFormatChanged(QTextBlockFormat)), scw, SLOT(setCurrentBlockFormat(QTextBlockFormat)));
+     connect(scw, SIGNAL(doneWithFocus()), this, SLOT(returnFocusToCanvas()));
+     connect(scw, SIGNAL(characterStyleSelected(KoCharacterStyle *)), this, SLOT(setStyle(KoCharacterStyle*)));
++    connect(scw, SIGNAL(newStyleRequested(QString)), this, SLOT(createStyleFromCurrentCharFormat(QString)));
++    connect(scw, SIGNAL(showStyleManager(int)), this, SLOT(showStyleManager()));
+ 
+ 
+     // Connect to/with simple paragraph widget (docker)
+@@ -1602,6 +1608,8 @@ QList<QWidget *> TextTool::createOptionWidgets()
+     connect(this, SIGNAL(blockFormatChanged(QTextBlockFormat)), spw, SLOT(setCurrentFormat(QTextBlockFormat)));
+     connect(spw, SIGNAL(doneWithFocus()), this, SLOT(returnFocusToCanvas()));
+     connect(spw, SIGNAL(paragraphStyleSelected(KoParagraphStyle *)), this, SLOT(setStyle(KoParagraphStyle*)));
++    connect(spw, SIGNAL(newStyleRequested(QString)), this, SLOT(createStyleFromCurrentBlockFormat(QString)));
++    connect(spw, SIGNAL(showStyleManager(int)), this, SLOT(showStyleManager()));
+ 
+     // Connect to/with simple table widget (docker)
+     connect(this, SIGNAL(styleManagerChanged(KoStyleManager *)), stw, SLOT(setStyleManager(KoStyleManager *)));
+@@ -1791,15 +1799,24 @@ void TextTool::insertIndexMarker()
+ 
+ void TextTool::setStyle(KoCharacterStyle *style)
+ {
+-    m_textEditor.data()->setStyle(style);
+-    emit charFormatChanged(m_textEditor.data()->charFormat());
++    KoCharacterStyle *charStyle;
++    //if the given KoCharacterStyle is null, set the KoParagraphStyle character properties
++    if (!style){
++        charStyle = static_cast<KoCharacterStyle*>(KoTextDocument(m_textShapeData->document()).styleManager()->paragraphStyle(m_textEditor.data()->blockFormat().intProperty(KoParagraphStyle::StyleId)));
++    }
++    else {
++        charStyle = style;
++    }
++    if (charStyle) {
++        m_textEditor.data()->setStyle(charStyle);
++        updateActions();
++    }
+ }
+ 
+ void TextTool::setStyle(KoParagraphStyle *style)
+ {
+     m_textEditor.data()->setStyle(style);
+-    emit blockFormatChanged(m_textEditor.data()->blockFormat());
+-    emit charFormatChanged(m_textEditor.data()->charFormat());
++    updateActions();
+ }
+ 
+ void TextTool::insertTable()
+@@ -2087,6 +2104,29 @@ void TextTool::shapeDataRemoved()
+     }
+ }
+ 
++void TextTool::createStyleFromCurrentBlockFormat(QString name)
++{
++    KoTextDocument document(m_textShapeData->document());
++    KoStyleManager *styleManager = document.styleManager();
++    KoParagraphStyle *paragraphStyle = new KoParagraphStyle(m_textEditor.data()->blockFormat(), m_textEditor.data()->charFormat());
++    paragraphStyle->setName(name);
++    styleManager->add(paragraphStyle);
++    m_textEditor.data()->setStyle(paragraphStyle);
++    emit charFormatChanged(m_textEditor.data()->charFormat());
++    emit blockFormatChanged(m_textEditor.data()->blockFormat());
++}
++
++void TextTool::createStyleFromCurrentCharFormat(QString name)
++{
++    KoTextDocument document(m_textShapeData->document());
++    KoStyleManager *styleManager = document.styleManager();
++    KoCharacterStyle *characterStyle = new KoCharacterStyle(m_textEditor.data()->charFormat());
++    characterStyle->setName(name);
++    styleManager->add(characterStyle);
++    m_textEditor.data()->setStyle(characterStyle);
++    emit charFormatChanged(m_textEditor.data()->charFormat());
++}
++
+ // ---------- editing plugins methods.
+ void TextTool::editingPluginEvents()
+ {
+diff --git a/plugins/textshape/TextTool.h b/plugins/textshape/TextTool.h
+index f8de126..e9a5090 100644
+--- a/plugins/textshape/TextTool.h
++++ b/plugins/textshape/TextTool.h
+@@ -3,6 +3,7 @@
+  * Copyright (C) 2008 Thorsten Zachmann <zachmann@kde.org>
+  * Copyright (C) 2009 KO GmbH <cbo@kogmbh.com>
+  * Copyright (C) 2011 Mojtaba Shahi Senobari <mojtaba.shahi3000@gmail.com>
++ * Copyright (C) 2008, 2012 Pierre Stirnweiss <pstirnweiss@googlemail.org>
+  *
+  * This library is free software; you can redistribute it and/or
+  * modify it under the terms of the GNU Library General Public
+@@ -286,16 +287,20 @@ private slots:
+ 
+     void ensureCursorVisible(bool moveView = true);
+ 
++    void createStyleFromCurrentBlockFormat(QString name);
++    void createStyleFromCurrentCharFormat(QString name);
++
+     void testSlot(bool);
+ 
+     /// change block text direction
+     void textDirectionChanged();
+ 
++    void updateActions();
++
+ private:
+     void repaintCaret();
+     void repaintSelection();
+     KoPointedAt hitTest(const QPointF & point) const;
+-    void updateActions();
+     void updateStyleManager();
+     void updateSelectedShape(const QPointF &point);
+     void updateSelectionHandler();
+diff --git a/plugins/textshape/dialogs/SimpleCharacterWidget.cpp b/plugins/textshape/dialogs/SimpleCharacterWidget.cpp
+index 6b2bb66..d132b92 100644
+--- a/plugins/textshape/dialogs/SimpleCharacterWidget.cpp
++++ b/plugins/textshape/dialogs/SimpleCharacterWidget.cpp
+@@ -1,6 +1,7 @@
+ /* This file is part of the KDE project
+  * Copyright (C) 2007, 2008, 2010 Thomas Zander <zander@kde.org>
+  * Copyright (C) 2009-2010 Casper Boemann <cbo@boemann.dk>
++ * Copyright (C) 2011-2012 Pierre Stirnweiss <pstirnweiss@googlemail.com>
+  *
+  * This library is free software; you can redistribute it and/or
+  * modify it under the terms of the GNU Library General Public
+@@ -17,20 +18,21 @@
+  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+  * Boston, MA 02110-1301, USA.
+  */
++
+ #include "SimpleCharacterWidget.h"
+ #include "TextTool.h"
+ #include "../commands/ChangeListCommand.h"
+-#include "StylesWidget.h"
+-#include "SpecialButton.h"
++#include "StylesModel.h"
++#include <KoStyleThumbnailer.h>
+ 
+ #include <KAction>
+ #include <KSelectAction>
+ #include <KoTextBlockData.h>
+ #include <KoCharacterStyle.h>
++#include <KoParagraphStyle.h>
+ #include <KoInlineTextObjectManager.h>
+ #include <KoTextDocumentLayout.h>
+ #include <KoZoomHandler.h>
+-#include <KoStyleThumbnailer.h>
+ #include <KoStyleManager.h>
+ 
+ #include <KDebug>
+@@ -78,32 +80,31 @@ SimpleCharacterWidget::SimpleCharacterWidget(TextTool *tool, QWidget *parent)
+ 
+     widget.fontsFrame->setColumnStretch(0,1);
+ 
+-    m_stylePopup = new StylesWidget(this, false, Qt::Popup);
+-    m_stylePopup->setFrameShape(QFrame::StyledPanel);
+-    m_stylePopup->setFrameShadow(QFrame::Raised);
+-    widget.charFrame->setStylesWidget(m_stylePopup);
++    m_thumbnailer = new KoStyleThumbnailer();
+ 
+-    connect(m_stylePopup, SIGNAL(characterStyleSelected(KoCharacterStyle *)), this, SIGNAL(characterStyleSelected(KoCharacterStyle *)));
+-    connect(m_stylePopup, SIGNAL(characterStyleSelected(KoCharacterStyle *)), this, SIGNAL(doneWithFocus()));
+-    connect(m_stylePopup, SIGNAL(characterStyleSelected(KoCharacterStyle *)), this, SLOT(hidePopup()));
++    m_stylesModel = new StylesModel(0, StylesModel::CharacterStyle);
++    m_stylesModel->setStyleThumbnailer(m_thumbnailer);
++    widget.characterStyleCombo->setStylesModel(m_stylesModel);
++    connect(widget.characterStyleCombo, SIGNAL(selectionChanged(int)), this, SLOT(styleSelected(int)));
++    connect(widget.characterStyleCombo, SIGNAL(newStyleRequested(QString)), this, SIGNAL(newStyleRequested(QString)));
++    connect(widget.characterStyleCombo, SIGNAL(newStyleRequested(QString)), this, SIGNAL(doneWithFocus()));
++    connect(widget.characterStyleCombo, SIGNAL(showStyleManager(int)), this, SLOT(slotShowStyleManager(int)));
+ 
+-    m_thumbnailer = new KoStyleThumbnailer();
+ }
+ 
+ SimpleCharacterWidget::~SimpleCharacterWidget()
+ {
++    //the model is set on the comboBox which takes ownership
+     delete m_thumbnailer;
+ }
+ 
+ void SimpleCharacterWidget::setStyleManager(KoStyleManager *sm)
+ {
+     m_styleManager = sm;
+-    m_stylePopup->setStyleManager(sm);
+-}
+-
+-void SimpleCharacterWidget::hidePopup()
+-{
+-    widget.charFrame->hidePopup();
++    //we want to disconnect this before setting the stylemanager. Populating the model apparently selects the first inserted item. We don't want this to actually set a new style.
++    disconnect(widget.characterStyleCombo, SIGNAL(selectionChanged(int)), this, SLOT(styleSelected(int)));
++    m_stylesModel->setStyleManager(sm);
++    connect(widget.characterStyleCombo, SIGNAL(selectionChanged(int)), this, SLOT(styleSelected(int)));
+ }
+ 
+ void SimpleCharacterWidget::setCurrentFormat(const QTextCharFormat& format)
+@@ -115,9 +116,60 @@ void SimpleCharacterWidget::setCurrentFormat(const QTextCharFormat& format)
+     int id = m_currentCharFormat.intProperty(KoCharacterStyle::StyleId);
+     KoCharacterStyle *style(m_styleManager->characterStyle(id));
+     if (style) {
+-        widget.charFrame->setStylePreview(m_thumbnailer->thumbnail(m_styleManager->characterStyle(id), widget.charFrame->contentsRect().size()));
++        bool unchanged = true;
++        foreach(int property, m_currentCharFormat.properties().keys()) {
++            if (property == QTextFormat::ObjectIndex)
++                continue;
++            if (property == KoCharacterStyle::ChangeTrackerId) { //internal property
++                continue;
++            }
++            if (property == KoCharacterStyle::InlineInstanceId) { //internal property
++                continue;
++            }
++            if (property == KoCharacterStyle::FontYStretch) { //internal property
++                continue;
++            }            if ((m_currentCharFormat.property(property) != style->value(property)) && !(style->value(property).isNull() && !m_currentCharFormat.property(property).toBool())) {
++            //the last check seems to work. might be cause of a bug. The problem is when comparing an unset property in the style with a set to {0, false, ...) property in the format (eg. set then unset bold)
++                unchanged = false;
++                break;
++            }
++        }
++        disconnect(widget.characterStyleCombo, SIGNAL(selectionChanged(int)), this, SLOT(styleSelected(int)));
++        widget.characterStyleCombo->setCurrentIndex(m_stylesModel->indexForCharacterStyle(*style).row());
++        widget.characterStyleCombo->setStyleIsOriginal(unchanged);
++        connect(widget.characterStyleCombo, SIGNAL(selectionChanged(int)), this, SLOT(styleSelected(int)));
++    }
++    else {
++        int parId = m_currentCharFormat.intProperty(KoParagraphStyle::StyleId);
++        style = static_cast<KoCharacterStyle*>(m_styleManager->paragraphStyle(parId));
++        if (style) {
++            bool unchanged = true;
++            foreach(int property, m_currentCharFormat.properties().keys()) {
++                if (property == QTextFormat::ObjectIndex) {
++                    continue;
++                }
++                if (property == KoCharacterStyle::ChangeTrackerId) { //internal property
++                    continue;
++                }
++                if (property == KoCharacterStyle::InlineInstanceId) { //internal property
++                    continue;
++                }
++                if (property == KoCharacterStyle::FontYStretch) { //internal property
++                    continue;
++                }
++                if ((m_currentCharFormat.property(property) != style->value(property)) && !(style->value(property).isNull() && !m_currentCharFormat.property(property).toBool())) {
++                    //the last check seems to work. might be cause of a bug. The problem is when comparing an unset property in the style with a set to {0, false, ...) property in the format (eg. set then unset bold)
++                    unchanged = false;
++                    break;
++                }
++            }
++            disconnect(widget.characterStyleCombo, SIGNAL(selectionChanged(int)), this, SLOT(styleSelected(int)));
++            widget.characterStyleCombo->setCurrentIndex(0); //TODO make it a bit more resilient
++            widget.characterStyleCombo->setStyleIsOriginal(unchanged);
++            widget.characterStyleCombo->slotUpdatePreview();
++            connect(widget.characterStyleCombo, SIGNAL(selectionChanged(int)), this, SLOT(styleSelected(int)));
++        }
+     }
+-    m_stylePopup->setCurrentFormat(format);
+ }
+ 
+ void SimpleCharacterWidget::fontFamilyActivated(int index) {
+@@ -151,4 +203,32 @@ void SimpleCharacterWidget::fontSizeActivated(int index) {
+     m_lastFontSizeIndex = index;
+ }
+ 
++void SimpleCharacterWidget::setCurrentBlockFormat(const QTextBlockFormat &format)
++{
++    if (format == m_currentBlockFormat)
++        return;
++    m_currentBlockFormat = format;
++
++    m_stylesModel->setCurrentParagraphStyle(format.intProperty(KoParagraphStyle::StyleId));
++    disconnect(widget.characterStyleCombo, SIGNAL(selectionChanged(int)), this, SLOT(styleSelected(int)));
++    widget.characterStyleCombo->slotUpdatePreview();
++    connect(widget.characterStyleCombo, SIGNAL(selectionChanged(int)), this, SLOT(styleSelected(int)));
++}
++
++void SimpleCharacterWidget::styleSelected(int index)
++{
++    KoCharacterStyle *charStyle = m_styleManager->characterStyle(m_stylesModel->index(index).internalId());
++
++    //if the selected item correspond to a null characterStyle, send the null pointer. the tool should set the characterStyle as per paragraph
++    emit characterStyleSelected(charStyle);
++    emit doneWithFocus();
++}
++
++void SimpleCharacterWidget::slotShowStyleManager(int index)
++{
++    int styleId = m_stylesModel->index(index).internalId();
++    emit showStyleManager(styleId);
++    emit doneWithFocus();
++}
++
+ #include <SimpleCharacterWidget.moc>
+diff --git a/plugins/textshape/dialogs/SimpleCharacterWidget.h b/plugins/textshape/dialogs/SimpleCharacterWidget.h
+index ad944a5..051267b 100644
+--- a/plugins/textshape/dialogs/SimpleCharacterWidget.h
++++ b/plugins/textshape/dialogs/SimpleCharacterWidget.h
+@@ -1,6 +1,7 @@
+ /* This file is part of the KDE project
+  * Copyright (C) 2007 Thomas Zander <zander@kde.org>
+  * Copyright (C) 2010 Casper Boemann <cbo@boemann.dk>
++ * Copyright (C) 2011-2012 Pierre Stirnweiss <pstirnweiss@googlemail.com>
+  *
+  * This library is free software; you can redistribute it and/or
+  * modify it under the terms of the GNU Library General Public
+@@ -29,8 +30,8 @@
+ class TextTool;
+ class KoStyleManager;
+ class KoCharacterStyle;
+-class StylesWidget;
+ class KoStyleThumbnailer;
++class StylesModel;
+ 
+ class SimpleCharacterWidget : public QWidget
+ {
+@@ -42,15 +43,19 @@ public:
+ public slots:
+     void setStyleManager(KoStyleManager *sm);
+     void setCurrentFormat(const QTextCharFormat& format);
++    void setCurrentBlockFormat(const QTextBlockFormat &format);
+ 
+ private slots:
+     void fontFamilyActivated(int index);
+     void fontSizeActivated(int index);
+-    void hidePopup();
++    void styleSelected(int index);
++    void slotShowStyleManager(int index);
+ 
+ signals:
+     void doneWithFocus();
+     void characterStyleSelected(KoCharacterStyle *);
++    void newStyleRequested(QString name);
++    void showStyleManager(int styleId);
+ 
+ private:
+     Ui::SimpleCharacterWidget widget;
+@@ -61,8 +66,9 @@ private:
+     int m_lastFontSizeIndex;
+     TextTool *m_tool;
+     QTextCharFormat m_currentCharFormat;
++    QTextBlockFormat m_currentBlockFormat;
+     KoStyleThumbnailer *m_thumbnailer;
+-    StylesWidget *m_stylePopup;
++    StylesModel *m_stylesModel;
+ };
+ 
+ #endif
+diff --git a/plugins/textshape/dialogs/SimpleCharacterWidget.ui b/plugins/textshape/dialogs/SimpleCharacterWidget.ui
+index e4f6d3b..9a049fe 100644
+--- a/plugins/textshape/dialogs/SimpleCharacterWidget.ui
++++ b/plugins/textshape/dialogs/SimpleCharacterWidget.ui
+@@ -111,25 +111,7 @@
+       </spacer>
+      </item>
+      <item row="0" column="0" colspan="9">
+-      <widget class="SpecialButton" name="charFrame">
+-       <property name="sizePolicy">
+-        <sizepolicy hsizetype="MinimumExpanding" vsizetype="Preferred">
+-         <horstretch>0</horstretch>
+-         <verstretch>32</verstretch>
+-        </sizepolicy>
+-       </property>
+-       <property name="minimumSize">
+-        <size>
+-         <width>0</width>
+-         <height>20</height>
+-        </size>
+-       </property>
+-       <property name="frameShape">
+-        <enum>QFrame::StyledPanel</enum>
+-       </property>
+-       <property name="frameShadow">
+-        <enum>QFrame::Raised</enum>
+-       </property>
++      <widget class="StylesCombo" name="characterStyleCombo">
+       </widget>
+      </item>
+     </layout>
+@@ -148,9 +130,9 @@
+  </widget>
+  <customwidgets>
+   <customwidget>
+-   <class>SpecialButton</class>
+-   <extends>QFrame</extends>
+-   <header>dialogs/SpecialButton.h</header>
++   <class>StylesCombo</class>
++   <extends>QComboBox</extends>
++   <header>dialogs/StylesCombo.h</header>
+    <container>1</container>
+   </customwidget>
+  </customwidgets>
+diff --git a/plugins/textshape/dialogs/SimpleParagraphWidget.cpp b/plugins/textshape/dialogs/SimpleParagraphWidget.cpp
+index cbfacfe..0ed005e 100644
+--- a/plugins/textshape/dialogs/SimpleParagraphWidget.cpp
++++ b/plugins/textshape/dialogs/SimpleParagraphWidget.cpp
+@@ -2,6 +2,7 @@
+  * Copyright (C) 2007, 2008, 2010 Thomas Zander <zander@kde.org>
+  * Copyright (C) 2009-2010 Casper Boemann <cbo@boemann.dk>
+  * Copyright (C) 2011 Mojtaba Shahi Senobari <mojtaba.shahi3000@gmail.com>
++ * Copyright (C) 2011-2012 Pierre Stirnweiss <pstirnweiss@googlemail.com>
+  *
+  * This library is free software; you can redistribute it and/or
+  * modify it under the terms of the GNU Library General Public
+@@ -22,8 +23,11 @@
+ #include "TextTool.h"
+ #include <ListItemsHelper.h>
+ #include "FormattingButton.h"
+-#include "StylesWidget.h"
+-#include "SpecialButton.h"
++#include <KoStyleThumbnailer.h>
++
++#include "StylesCombo.h"
++#include "StylesModel.h"
++#include "StylesDelegate.h"
+ 
+ #include <KAction>
+ #include <KoTextBlockData.h>
+@@ -31,19 +35,20 @@
+ #include <KoInlineTextObjectManager.h>
+ #include <KoTextDocumentLayout.h>
+ #include <KoZoomHandler.h>
+-#include <KoStyleThumbnailer.h>
+ #include <KoStyleManager.h>
+ #include <KoListLevelProperties.h>
+ #include <KoShapePaintingContext.h>
+ #include <KDebug>
+ 
+ #include <QTextLayout>
++#include <QFlags>
+ 
+ SimpleParagraphWidget::SimpleParagraphWidget(TextTool *tool, QWidget *parent)
+         : QWidget(parent),
+-        m_blockSignals(false),
+-        m_tool(tool),
+-        m_directionButtonState(Auto)
++          m_blockSignals(false),
++          m_tool(tool),
++          m_directionButtonState(Auto),
++          m_stylesModel(0)
+ {
+     widget.setupUi(this);
+     widget.alignCenter->setDefaultAction(tool->action("format_aligncenter"));
+@@ -80,20 +85,19 @@ SimpleParagraphWidget::SimpleParagraphWidget(TextTool *tool, QWidget *parent)
+     connect(widget.bulletListButton, SIGNAL(itemTriggered(int)), this, SLOT(listStyleChanged(int)));
+     connect(widget.numberedListButton, SIGNAL(itemTriggered(int)), this, SLOT(listStyleChanged(int)));
+ 
+-    m_stylePopup = new StylesWidget(this, true, Qt::Popup);
+-    m_stylePopup->setFrameShape(QFrame::StyledPanel);
+-    m_stylePopup->setFrameShadow(QFrame::Raised);
+-    widget.blockFrame->setStylesWidget(m_stylePopup);
+-
+-    connect(m_stylePopup, SIGNAL(paragraphStyleSelected(KoParagraphStyle *)), this, SIGNAL(paragraphStyleSelected(KoParagraphStyle *)));
+-    connect(m_stylePopup, SIGNAL(paragraphStyleSelected(KoParagraphStyle *)), this, SIGNAL(doneWithFocus()));
+-    connect(m_stylePopup, SIGNAL(paragraphStyleSelected(KoParagraphStyle *)), this, SLOT(hidePopup()));
+-
+     m_thumbnailer = new KoStyleThumbnailer();
++    m_stylesModel = new StylesModel(0, StylesModel::ParagraphStyle);
++    m_stylesModel->setStyleThumbnailer(m_thumbnailer);
++    widget.paragraphStyleCombo->setStylesModel(m_stylesModel);
++    connect(widget.paragraphStyleCombo, SIGNAL(selectionChanged(int)), this, SLOT(styleSelected(int)));
++    connect(widget.paragraphStyleCombo, SIGNAL(newStyleRequested(QString)), this, SIGNAL(newStyleRequested(QString)));
++    connect(widget.paragraphStyleCombo, SIGNAL(newStyleRequested(QString)), this, SIGNAL(doneWithFocus()));
++    connect(widget.paragraphStyleCombo, SIGNAL(showStyleManager(int)), this, SLOT(slotShowStyleManager(int)));
+ }
+ 
+ SimpleParagraphWidget::~SimpleParagraphWidget()
+ {
++    //the style model is set on the comboBox who takes over ownership
+     delete m_thumbnailer;
+ }
+ 
+@@ -152,6 +156,10 @@ void SimpleParagraphWidget::fillListButtons()
+ 
+ void SimpleParagraphWidget::setCurrentBlock(const QTextBlock &block)
+ {
++    if (block == m_currentBlock) {
++        return;
++    }
++
+     m_currentBlock = block;
+     m_blockSignals = true;
+     struct Finally {
+@@ -180,15 +188,51 @@ void SimpleParagraphWidget::setCurrentBlock(const QTextBlock &block)
+             }
+     }
+ 
++    if (m_currentBlockFormat == m_currentBlock.blockFormat()) {
++        return;
++    }
++    m_currentBlockFormat = m_currentBlock.blockFormat();
+ 
+-    QTextBlockFormat format;
+-
+-    int id = format.intProperty(KoParagraphStyle::StyleId);
++    int id = m_currentBlockFormat.intProperty(KoParagraphStyle::StyleId);
+     KoParagraphStyle *style(m_styleManager->paragraphStyle(id));
+     if (style) {
+-        widget.blockFrame->setStylePreview(m_thumbnailer->thumbnail(style, widget.blockFrame->size()));
++        bool unchanged = true;
++        foreach(int property, m_currentBlockFormat.properties().keys()) {
++            if (property == QTextFormat::ObjectIndex)
++                continue;
++            if (property == KoParagraphStyle::ListStyleId)
++                continue;
++            if (property == QTextBlockFormat::BlockAlignment) { //the default alignment can be retrieved in the defaultTextOption. However, calligra sets the Qt::AlignAbsolute flag, so we need to or this flag with the default alignment before comparing.
++                if ((m_currentBlockFormat.property(property) != style->value(property))
++                        && !(style->value(property).isNull()
++                             && ((m_currentBlockFormat.intProperty(property)) == int(m_currentBlock.document()->defaultTextOption().alignment()| Qt::AlignAbsolute)))) {
++                    unchanged = false;
++                    break;
++                }
++                else {
++                    continue;
++                }
++            }
++            if (property == KoParagraphStyle::TextProgressionDirection) {
++                if (style->value(property).isNull() && m_currentBlockFormat.intProperty(property) == KoText::LeftRightTopBottom) {
++                    //LTR seems to be Qt default when unset
++                    continue;
++                }
++            }
++            if ((m_currentBlockFormat.property(property) != style->value(property)) && !(style->value(property).isNull() && !m_currentBlockFormat.property(property).toBool())) {
++                //the last check seems to work. might be cause of a bug. The problem is when comparing an unset property in the style with a set to {0, false, ...) property in the format (eg. set then unset bold)
++                unchanged = false;
++                break;
++            }
++        }
++
++        //we are updating the combo's selected item to what is the current format. we do not want this to apply the style as it would mess up the undo stack, the change tracking,...
++        disconnect(widget.paragraphStyleCombo, SIGNAL(selectionChanged(int)), this, SLOT(styleSelected(int)));
++        widget.paragraphStyleCombo->setCurrentIndex(m_stylesModel->indexForParagraphStyle(*style).row());
++        widget.paragraphStyleCombo->setStyleIsOriginal(unchanged);
++        m_stylesModel->setCurrentParagraphStyle(id);
++        connect(widget.paragraphStyleCombo, SIGNAL(selectionChanged(int)), this, SLOT(styleSelected(int)));
+     }
+-    m_stylePopup->setCurrentFormat(format);
+ }
+ 
+ void SimpleParagraphWidget::setCurrentFormat(const QTextBlockFormat &format)
+@@ -200,27 +244,74 @@ void SimpleParagraphWidget::setCurrentFormat(const QTextBlockFormat &format)
+     int id = m_currentBlockFormat.intProperty(KoParagraphStyle::StyleId);
+     KoParagraphStyle *style(m_styleManager->paragraphStyle(id));
+     if (style) {
+-        widget.blockFrame->setStylePreview(m_thumbnailer->thumbnail(m_styleManager->paragraphStyle(id), widget.blockFrame->contentsRect().size()));
++        bool unchanged = true;
++        foreach(int property, m_currentBlockFormat.properties().keys()) {
++            if (property == QTextFormat::ObjectIndex)
++                continue;
++            if (property == KoParagraphStyle::ListStyleId)
++                continue;
++            if (property == QTextBlockFormat::BlockAlignment) { //the default alignment can be retrieved in the defaultTextOption. However, calligra sets the Qt::AlignAbsolute flag, so we need to or this flag with the default alignment before comparing.
++                if ((m_currentBlockFormat.property(property) != style->value(property))
++                        && !(style->value(property).isNull()
++                             && ((m_currentBlockFormat.intProperty(property)) == int(m_currentBlock.document()->defaultTextOption().alignment()| Qt::AlignAbsolute)))) {
++                    unchanged = false;
++                    break;
++                }
++                else {
++                    continue;
++                }
++            }
++            if (property == KoParagraphStyle::TextProgressionDirection) {
++                if (style->value(property).isNull() && m_currentBlockFormat.intProperty(property) == KoText::LeftRightTopBottom) {
++                    //LTR seems to be Qt default when unset
++                    continue;
++                }
++            }
++            if ((m_currentBlockFormat.property(property) != style->value(property)) && !(style->value(property).isNull() && !m_currentBlockFormat.property(property).toBool())) {
++                //the last check seems to work. might be cause of a bug. The problem is when comparing an unset property in the style with a set to {0, false, ...) property in the format (eg. set then unset bold)
++                unchanged = false;
++                break;
++            }
++        }
++        //we are updating the combo's selected item to what is the current format. we do not want this to apply the style as it would mess up the undo stack, the change tracking,...
++        disconnect(widget.paragraphStyleCombo, SIGNAL(selectionChanged(int)), this, SLOT(styleSelected(int)));
++        widget.paragraphStyleCombo->setCurrentIndex(m_stylesModel->indexForParagraphStyle(*style).row());
++        widget.paragraphStyleCombo->setStyleIsOriginal(unchanged);
++        m_stylesModel->setCurrentParagraphStyle(id);
++        connect(widget.paragraphStyleCombo, SIGNAL(selectionChanged(int)), this, SLOT(styleSelected(int)));
+     }
+-    m_stylePopup->setCurrentFormat(format);
+ }
+ 
+ void SimpleParagraphWidget::setStyleManager(KoStyleManager *sm)
+ {
+     m_styleManager = sm;
+-    m_stylePopup->setStyleManager(sm);
++    //we want to disconnect this before setting the stylemanager. Populating the model apparently selects the first inserted item. We don't want this to actually set a new style.
++    disconnect(widget.paragraphStyleCombo, SIGNAL(selectionChanged(int)), this, SLOT(styleSelected(int)));
++    m_stylesModel->setStyleManager(sm);
++    connect(widget.paragraphStyleCombo, SIGNAL(selectionChanged(int)), this, SLOT(styleSelected(int)));
+ }
+ 
+-void SimpleParagraphWidget::hidePopup()
++void SimpleParagraphWidget::listStyleChanged(int id)
+ {
+-    widget.blockFrame->hidePopup();
++    emit doneWithFocus();
++    if (m_blockSignals) return;
++    m_tool->textEditor()->setListProperties(static_cast<KoListStyle::Style>(id));
+ }
+ 
+-void SimpleParagraphWidget::listStyleChanged(int id)
++void SimpleParagraphWidget::styleSelected(int index)
+ {
++    KoParagraphStyle *paragStyle = m_styleManager->paragraphStyle(m_stylesModel->index(index).internalId());
++    if (paragStyle) {
++        emit paragraphStyleSelected(paragStyle);
++    }
++    emit doneWithFocus();
++}
++
++void SimpleParagraphWidget::slotShowStyleManager(int index)
++{
++    int styleId = m_stylesModel->index(index).internalId();
++    emit showStyleManager(styleId);
+     emit doneWithFocus();
+-    if (m_blockSignals) return;
+-    m_tool->textEditor()->setListProperties(static_cast<KoListStyle::Style> (id));
+ }
+ 
+ #include <SimpleParagraphWidget.moc>
+diff --git a/plugins/textshape/dialogs/SimpleParagraphWidget.h b/plugins/textshape/dialogs/SimpleParagraphWidget.h
+index bc167b4..e07be88 100644
+--- a/plugins/textshape/dialogs/SimpleParagraphWidget.h
++++ b/plugins/textshape/dialogs/SimpleParagraphWidget.h
+@@ -2,6 +2,7 @@
+  * Copyright (C) 2007 Thomas Zander <zander@kde.org>
+  * Copyright (C) 2010 Casper Boemann <cbo@boemann.dk>
+  * Copyright (C) 2011 Mojtaba Shahi Senobari <mojtaba.shahi3000@gmail.com>
++ * Copyright (C) 2011-2012 Pierre Stirnweiss <pstirnweiss@googlemail.com>
+  *
+  * This library is free software; you can redistribute it and/or
+  * modify it under the terms of the GNU Library General Public
+@@ -29,9 +30,11 @@
+ class TextTool;
+ class KoStyleManager;
+ class KoParagraphStyle;
+-class StylesWidget;
+ class KoStyleThumbnailer;
+ 
++class StylesModel;
++class StylesDelegate;
++
+ class SimpleParagraphWidget : public QWidget
+ {
+     Q_OBJECT
+@@ -43,14 +46,17 @@ public slots:
+     void setCurrentBlock(const QTextBlock &block);
+     void setCurrentFormat(const QTextBlockFormat& format);
+     void setStyleManager(KoStyleManager *sm);
+-    void hidePopup();
++    void slotShowStyleManager(int index);
+ 
+ signals:
+     void doneWithFocus();
+     void paragraphStyleSelected(KoParagraphStyle *);
++    void newStyleRequested(QString name);
++    void showStyleManager(int styleId);
+ 
+ private slots:
+     void listStyleChanged(int id);
++    void styleSelected(int index);
+ 
+ private:
+     enum DirectionButtonState {
+@@ -72,7 +78,9 @@ private:
+     TextTool *m_tool;
+     DirectionButtonState m_directionButtonState;
+     KoStyleThumbnailer *m_thumbnailer;
+-    StylesWidget *m_stylePopup;
++
++    StylesModel *m_stylesModel;
++    StylesDelegate *m_stylesDelegate;
+ };
+ 
+ #endif
+diff --git a/plugins/textshape/dialogs/SimpleParagraphWidget.ui b/plugins/textshape/dialogs/SimpleParagraphWidget.ui
+index b2e9adf..572055f 100644
+--- a/plugins/textshape/dialogs/SimpleParagraphWidget.ui
++++ b/plugins/textshape/dialogs/SimpleParagraphWidget.ui
+@@ -118,25 +118,7 @@
+       </spacer>
+      </item>
+      <item row="1" column="0" colspan="11">
+-      <widget class="SpecialButton" name="blockFrame">
+-       <property name="sizePolicy">
+-        <sizepolicy hsizetype="MinimumExpanding" vsizetype="Preferred">
+-         <horstretch>0</horstretch>
+-         <verstretch>32</verstretch>
+-        </sizepolicy>
+-       </property>
+-       <property name="minimumSize">
+-        <size>
+-         <width>0</width>
+-         <height>0</height>
+-        </size>
+-       </property>
+-       <property name="frameShape">
+-        <enum>QFrame::StyledPanel</enum>
+-       </property>
+-       <property name="frameShadow">
+-        <enum>QFrame::Raised</enum>
+-       </property>
++      <widget class="StylesCombo" name="paragraphStyleCombo">
+       </widget>
+      </item>
+      <item row="2" column="10">
+@@ -163,9 +145,9 @@
+    <header>dialogs/FormattingButton.h</header>
+   </customwidget>
+   <customwidget>
+-   <class>SpecialButton</class>
+-   <extends>QFrame</extends>
+-   <header>dialogs/SpecialButton.h</header>
++   <class>StylesCombo</class>
++   <extends>QComboBox</extends>
++   <header>dialogs/StylesCombo.h</header>
+    <container>1</container>
+   </customwidget>
+  </customwidgets>
+diff --git a/plugins/textshape/dialogs/StylesCombo.cpp b/plugins/textshape/dialogs/StylesCombo.cpp
+new file mode 100644
+index 0000000..5147fb5
+--- /dev/null
++++ b/plugins/textshape/dialogs/StylesCombo.cpp
+@@ -0,0 +1,188 @@
++/* This file is part of the KDE project
++ * Copyright (C) 2011-2012 Pierre Stirnweiss <pstirnweiss@googlemail.com>
++ *
++ * This library is free software; you can redistribute it and/or
++ * modify it under the terms of the GNU Library General Public
++ * License as published by the Free Software Foundation; either
++ * version 2 of the License, or (at your option) any later version.
++ *
++ * This library is distributed in the hope that it will be useful,
++ * but WITHOUT ANY WARRANTY; without even the implied warranty of
++ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++ * Library General Public License for more details.
++ *
++ * You should have received a copy of the GNU Library General Public License
++ * along with this library; see the file COPYING.LIB.  If not, write to
++ * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
++ * Boston, MA 02110-1301, USA.
++*/
++#include "StylesCombo.h"
++#include <KoStyleThumbnailer.h>
++
++#include "StylesModel.h"
++#include "StylesComboPreview.h"
++#include "StylesDelegate.h"
++
++#include <QApplication>
++#include <QListView>
++#include <QSizePolicy>
++#include <QWidget>
++#include <QMouseEvent>
++#include <QPoint>
++#include <QStyleOptionComboBox>
++#include <QStyleOptionViewItemV4>
++#include <QStylePainter>
++
++#include <KDebug>
++
++StylesCombo::StylesCombo(QWidget *parent)
++    : QComboBox(parent),
++      m_stylesModel(0),
++      m_view(new QListView()),
++      m_selectedItem(-1),
++      m_originalStyle(true)
++{
++    setMinimumSize(50,32);
++
++    m_view->setMinimumWidth(250);
++    m_view->setMouseTracking(true);
++    setView(m_view);
++    view()->viewport()->installEventFilter(this);
++
++    StylesDelegate *delegate = new StylesDelegate();
++    connect(delegate, SIGNAL(needsUpdate(QModelIndex)), m_view, SLOT(update(QModelIndex)));
++    connect(delegate, SIGNAL(styleManagerButtonClicked(QModelIndex)), this, SLOT(slotShowDia(QModelIndex)));
++    connect(delegate, SIGNAL(deleteStyleButtonClicked(QModelIndex)), this, SLOT(slotDeleteStyle(QModelIndex)));
++    connect(delegate, SIGNAL(clickedInItem(QModelIndex)), this, SLOT(slotItemClicked(QModelIndex)));
++    setItemDelegate(delegate);
++
++    connect(this, SIGNAL(currentIndexChanged(int)), this, SLOT(slotSelectionChanged(int)));
++
++    QComboBox::setEditable(true);
++    setIconSize(QSize(0,0));
++
++    StylesComboPreview *preview = new StylesComboPreview(this);
++    connect(preview, SIGNAL(newStyleRequested(QString)), this, SIGNAL(newStyleRequested(QString)));
++    QComboBox::setEditable(true);
++    setLineEdit(preview);
++}
++
++StylesCombo::~StylesCombo()
++{
++}
++
++void StylesCombo::setStyleIsOriginal(bool original)
++{
++    m_originalStyle = original;
++    if (!original) {
++        m_preview->setAddButtonShown(true);
++    }
++    else {
++        m_preview->setAddButtonShown(false);
++    }
++}
++
++void StylesCombo::setStylesModel(StylesModel *model)
++{
++    m_stylesModel = model;
++    setModel(model);
++}
++
++void StylesCombo::setEditable(bool editable)
++{
++    if (editable) {
++        // Create a StylesComboPreview instead of a QLineEdit
++        // Compared to QComboBox::setEditable, we might be missing the SH_ComboBox_Popup code though...
++        // If a style needs this, then we'll need to call QComboBox::setEditable and then setLineEdit again
++        StylesComboPreview *edit = new StylesComboPreview( this );
++        setLineEdit( edit );
++    } else {
++        QComboBox::setEditable(editable);
++    }
++}
++
++void StylesCombo::setLineEdit(QLineEdit *edit)
++{
++    if ( !isEditable() && edit &&
++         !qstrcmp( edit->metaObject()->className(), "QLineEdit" ) )
++    {
++        // uic generates code that creates a read-only StylesCombo and then
++        // calls combo->setEditable( true ), which causes QComboBox to set up
++        // a dumb QLineEdit instead of our nice StylesComboPreview.
++        // As some StylesCombo features rely on the StylesComboPreview, we reject
++        // this order here.
++        delete edit;
++        StylesComboPreview* preview = new StylesComboPreview( this );
++        edit = preview;
++    }
++
++    QComboBox::setLineEdit( edit );
++    m_preview = qobject_cast<StylesComboPreview*>( edit );
++
++    if ( m_preview )
++    {
++        connect(m_preview, SIGNAL(resized()), this, SLOT(slotUpdatePreview()));
++    }
++
++}
++
++void StylesCombo::slotSelectionChanged(int index)
++{
++    if (index != m_selectedItem || !m_originalStyle) {
++        m_selectedItem = index;
++        m_preview->setPreview(m_stylesModel->stylePreview(index, m_preview->availableSize()));
++        update();
++        emit selectionChanged(index);
++    }
++}
++
++void StylesCombo::slotItemClicked(QModelIndex index)
++{
++    //this slot allows us to emit a selectionChanged signal in case the already selected style isn't in its original form anymore. In such case, the view does not emit currentIndexChanged, so we use the editorEvent of the delegate to send us a signal. There is a bit of redundancy if the item clicked was indeed a new selection, hence the check in both slots.
++    if (index.row() != m_selectedItem || !m_originalStyle) {
++        m_selectedItem = index.row();
++        m_preview->setPreview(m_stylesModel->stylePreview(m_selectedItem, m_preview->availableSize()));
++        update();
++        emit selectionChanged(m_selectedItem);
++    }
++}
++
++void StylesCombo::slotUpdatePreview()
++{
++    m_preview->setPreview(m_stylesModel->stylePreview(currentIndex(), m_preview->availableSize()));
++    update();
++}
++
++bool StylesCombo::eventFilter(QObject *object, QEvent *event)
++{
++    if (event->type() == QEvent::MouseButtonRelease && object == view()->viewport()) {
++        QMouseEvent *mouseEvent = static_cast<QMouseEvent*>(event);
++        //If what follows isn't a HACK then I have no clue what is!!!!
++        //The item delegate editorEvent method is not sent MouseButtonRelease events.
++        //This is because the QComboBox installs an event filter on the view and calls
++        //popup->hide() on MouseButtonRelease to dismiss the view. Since we installed an event filter on the view
++        //ourselves, we can prevent hiding the popup. We have to call itemDelegate->editorEvent
++        //manually though.
++        QModelIndex index = view()->indexAt(mouseEvent->pos());
++        QModelIndex buddy = m_stylesModel->buddy(index);
++        QStyleOptionViewItemV4 options;
++        options.rect = view()->visualRect(buddy);
++        options.widget = m_view;
++        options.state |= (buddy == view()->currentIndex() ? QStyle::State_HasFocus : QStyle::State_None);
++        return view()->itemDelegate()->editorEvent(mouseEvent, m_stylesModel, options, index);
++    }
++    return false;
++}
++
++void StylesCombo::slotShowDia(QModelIndex index)
++{
++    emit showStyleManager(index.row());
++}
++
++void StylesCombo::slotDeleteStyle(QModelIndex index)
++{
++    emit deleteStyle(index.row());
++}
++
++#include <StylesCombo.moc>
++
+diff --git a/plugins/textshape/dialogs/StylesCombo.h b/plugins/textshape/dialogs/StylesCombo.h
+new file mode 100644
+index 0000000..2bd4dfb
+--- /dev/null
++++ b/plugins/textshape/dialogs/StylesCombo.h
+@@ -0,0 +1,93 @@
++/* This file is part of the KDE project
++ * Copyright (C) 2011-2012 Pierre Stirnweiss <pstirnweiss@googlemail.com>
++ *
++ * This library is free software; you can redistribute it and/or
++ * modify it under the terms of the GNU Library General Public
++ * License as published by the Free Software Foundation; either
++ * version 2 of the License, or (at your option) any later version.
++ *
++ * This library is distributed in the hope that it will be useful,
++ * but WITHOUT ANY WARRANTY; without even the implied warranty of
++ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++ * Library General Public License for more details.
++ *
++ * You should have received a copy of the GNU Library General Public License
++ * along with this library; see the file COPYING.LIB.  If not, write to
++ * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
++ * Boston, MA 02110-1301, USA.
++ */
++#ifndef STYLESCOMBO_H
++#define STYLESCOMBO_H
++
++#include <QComboBox>
++
++class QListView;
++
++class StylesModel;
++class StylesComboPreview;
++
++/** This combo is specifically designed to allow chosing a text style, be it a character style or a paragraph style.
++  * The combo itself does not know what type of style it is dealing with. In that respect it follows pretty much the normal QComboBox paradigm.
++  * This is achieved by setting a @class StylesModel to the combo.
++  * The combo also creates and uses a @class StylesDelegate in order to paint the items as preview in the dropdown menu. This delegate also provide a button to call the style manager dialog directly.
++  * Additionally the combo display the style as a preview in its main area.
++  * The combo allows its user to specify if the current selected style should be considered as original or not. If the style has been modified, a + button appears in the main area. Pressing it will allow to change the name of the style. Focusing out, or pressing enter will send a signal for creating a new style. Escaping will prevent this signal to be sent and return to the preview.
++*/
++
++class StylesCombo : public QComboBox
++{
++    Q_OBJECT
++public:
++    StylesCombo(QWidget *parent);
++    ~StylesCombo();
++
++    /** Use this method to set the @param model of the combo. */
++    void setStylesModel(StylesModel *model);
++
++    /** This method is an override of QComboBox setLineEdit. We need to make it public since its Qt counterpart is public. However, this method is not supposed to be used (unless you know what you are doing). The StylesCombo relies on its own internal QLineEdit subclass for quite a lot of its functionnality. There is no guarantee that the whole thing will work in case the line edit is replaced */
++    void setLineEdit(QLineEdit *lineEdit);
++    /** Same as above */
++    void setEditable(bool editable);
++
++    /** This method is used to specify if the currently selected style is in its original state or is considered modified. In the later case, the + button will appear (see the class description) */
++    void setStyleIsOriginal(bool original);
++
++    bool eventFilter(QObject *, QEvent *);
++
++public slots:
++    /** This slot needs to be called if the preview in the main area needs to be updated for some reason */
++    void slotUpdatePreview();
++
++signals:
++    /** As a normal QComboBox, this is emitted when the selection is changed (programatically or by user interaction). It is to be noted that this signal is also emitted in case a style which is considered modified is selected again.
++      * @param index: the index of the selected item. */
++    void selectionChanged(int index);
++
++    /** This signal is emitted on validation of the name of a modified style (after pressing the + button). This validation happens on focus out or pressed enter key.
++      * @param name: the name by which the new style should be called */
++    void newStyleRequested(QString name);
++
++    /** This signal is emitted when the "show style manager" button is pressed in the dropdown list.
++      * @param index: the index of the item on which the button was pressed */
++    void showStyleManager(int index);
++
++    /** This signal is emitted when the "delete style" button is pressed in the dropdown list.
++      * @param index: the index of the item on which the button was pressed
++      * This is currently disabled */
++    void deleteStyle(int index);
++
++private slots:
++    void slotDeleteStyle(QModelIndex);
++    void slotShowDia(QModelIndex);
++    void slotSelectionChanged(int index);
++    void slotItemClicked(QModelIndex);
++
++private:
++    StylesModel *m_stylesModel;
++    StylesComboPreview *m_preview;
++    QListView *m_view;
++    int m_selectedItem;
++    bool m_originalStyle;
++};
++
++#endif //STYLESCOMBO_H
+diff --git a/plugins/textshape/dialogs/StylesComboPreview.cpp b/plugins/textshape/dialogs/StylesComboPreview.cpp
+new file mode 100644
+index 0000000..c07dff8
+--- /dev/null
++++ b/plugins/textshape/dialogs/StylesComboPreview.cpp
+@@ -0,0 +1,190 @@
++/* This file is part of the KDE project
++ * Copyright (C) 2011 Pierre Stirnweiss <pstirnweiss@googlemail.com>
++ *
++ * This library is free software; you can redistribute it and/or
++ * modify it under the terms of the GNU Library General Public
++ * License as published by the Free Software Foundation; either
++ * version 2 of the License, or (at your option) any later version.
++ *
++ * This library is distributed in the hope that it will be useful,
++ * but WITHOUT ANY WARRANTY; without even the implied warranty of
++ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++ * Library General Public License for more details.
++ *
++ * You should have received a copy of the GNU Library General Public License
++ * along with this library; see the file COPYING.LIB.  If not, write to
++ * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
++ * Boston, MA 02110-1301, USA.
++*/
++
++/*
++ * This class is heavily inspired by KLineEdit, so here goes credit because credit is due (from klineedit.h):
++ *  This class was originally inspired by Torben Weis'
++ *  fileentry.cpp for KFM II.
++
++ *  Sven Radej <sven.radej@iname.com>
++ *  Patrick Ward <PAT_WARD@HP-USA-om5.om.hp.com>
++ *  Preston Brown <pbrown@kde.org>
++
++ *  Completely re-designed:
++ *  Dawit Alemayehu <adawit@kde.org>
++
++*/
++
++#include "StylesComboPreview.h"
++
++#include <QImage>
++#include <QLineEdit>
++#include <QModelIndex>
++#include <QPainter>
++#include <QPaintEvent>
++#include <QFocusEvent>
++#include <QMouseEvent>
++#include <QKeyEvent>
++#include <QPushButton>
++#include <QString>
++
++#include <KIcon>
++#include <KLocale>
++
++#include <KDebug>
++
++StylesComboPreview::StylesComboPreview(QWidget *parent) :
++    QLineEdit(parent),
++    m_renamingNewStyle(false),
++    m_shouldAddNewStyle(false),
++    m_addButton(0)
++{
++    init();
++}
++
++StylesComboPreview::~StylesComboPreview()
++{
++    delete m_addButton;
++    m_addButton = 0;
++}
++
++void StylesComboPreview::init()
++{
++    setReadOnly(true);
++    if (m_addButton) {
++        return;
++    }
++
++    m_addButton = new QPushButton(this);
++    m_addButton->setCursor( Qt::ArrowCursor );
++    m_addButton->setIcon(KIcon("list-add"));
++    m_addButton->setFlat(true);
++    m_addButton->setMinimumSize(16,16);
++    m_addButton->setMaximumSize(16, 16);
++//TODO uncomment the following line after string freeze
++//    m_addButton->setToolTip( i18nc( "@action:button Create a new style with the current properties", "Create style" ) );
++    connect(m_addButton, SIGNAL(clicked()), this, SLOT(addNewStyle()));
++
++    updateAddButton();
++}
++
++void StylesComboPreview::updateAddButton()
++{
++    if (!m_addButton) {
++        return;
++    }
++
++    const QSize geom = size();
++    const int buttonWidth = m_addButton->size().width();
++    m_addButton->move(geom.width() - buttonWidth , (geom.height()-m_addButton->size().height())/2);
++}
++
++void StylesComboPreview::setAddButtonShown(bool show)
++{
++    m_addButton->setVisible(show);
++}
++
++QSize StylesComboPreview::availableSize() const
++{
++    return QSize(contentsRect().width()- m_addButton->width(), contentsRect().height()); ///TODO dynamic resizing when button shown/hidden.
++}
++
++void StylesComboPreview::setPreview(QImage image)
++{
++    m_stylePreview = image;
++}
++
++bool StylesComboPreview::isAddButtonShown() const
++{
++    return m_addButton != 0;
++}
++
++void StylesComboPreview::resizeEvent( QResizeEvent * ev )
++{
++    QLineEdit::resizeEvent(ev);
++    emit resized();
++    updateAddButton();
++}
++
++void StylesComboPreview::keyPressEvent( QKeyEvent *e )
++{
++    if (m_shouldAddNewStyle && e->key() == Qt::Key_Escape) {
++        m_renamingNewStyle = false;
++        m_shouldAddNewStyle = false;
++        setReadOnly(true);
++        setText(QString());
++        e->accept();
++    }
++    else if (m_shouldAddNewStyle && (e->key() == Qt::Key_Enter || e->key() == Qt::Key_Return)) {
++        m_renamingNewStyle = false;
++        m_shouldAddNewStyle = false;
++        emit newStyleRequested(text());
++        setReadOnly(true);
++        setText(QString());
++        e->accept();
++    }
++    else {
++        QLineEdit::keyPressEvent(e);
++    }
++}
++
++void StylesComboPreview::focusOutEvent(QFocusEvent *e)
++{
++    if (e->reason() != Qt::ActiveWindowFocusReason && e->reason() != Qt::PopupFocusReason) {
++        if (m_shouldAddNewStyle) {
++            m_renamingNewStyle = false;
++            m_shouldAddNewStyle = false;
++            emit newStyleRequested(text());
++            setReadOnly(true);
++            setText(QString());
++            e->accept();
++        }
++        setReadOnly(true);
++        m_renamingNewStyle = false;
++        setText(QString());
++    }
++    else {
++        QLineEdit::focusOutEvent(e);
++    }
++}
++
++void StylesComboPreview::paintEvent( QPaintEvent *ev )
++{
++    if (!m_renamingNewStyle) {
++        QLineEdit::paintEvent(ev);
++        QPainter p(this);
++        p.setClipRect(ev->rect());
++        p.drawImage(contentsRect().topLeft(), m_stylePreview);
++    }
++    else {
++        QLineEdit::paintEvent(ev);
++    }
++}
++
++void StylesComboPreview::addNewStyle()
++{
++    m_renamingNewStyle = true;
++    m_shouldAddNewStyle = true;
++    setText(i18n("New style"));
++    selectAll();
++    setReadOnly(false);
++    this->setFocus();
++}
++
++#include "StylesComboPreview.moc"
+diff --git a/plugins/textshape/dialogs/StylesComboPreview.h b/plugins/textshape/dialogs/StylesComboPreview.h
+new file mode 100644
+index 0000000..e98ebf4
+--- /dev/null
++++ b/plugins/textshape/dialogs/StylesComboPreview.h
+@@ -0,0 +1,74 @@
++/* This file is part of the KDE project
++ * Copyright (C) 2011 Pierre Stirnweiss <pstirnweiss@googlemail.com>
++ *
++ * This library is free software; you can redistribute it and/or
++ * modify it under the terms of the GNU Library General Public
++ * License as published by the Free Software Foundation; either
++ * version 2 of the License, or (at your option) any later version.
++ *
++ * This library is distributed in the hope that it will be useful,
++ * but WITHOUT ANY WARRANTY; without even the implied warranty of
++ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++ * Library General Public License for more details.
++ *
++ * You should have received a copy of the GNU Library General Public License
++ * along with this library; see the file COPYING.LIB.  If not, write to
++ * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
++ * Boston, MA 02110-1301, USA.
++*/
++
++#ifndef STYLESCOMBOPREVIEW_H
++#define STYLESCOMBOPREVIEW_H
++
++#include <QLineEdit>
++
++class QModelIndex;
++class QImage;
++class QPushButton;
++class QSize;
++class QString;
++
++/** This is an internal class, used for the preview of styles in the main area of the @class StylesCombo. */
++
++class StylesComboPreview : public QLineEdit
++{
++    Q_OBJECT
++
++    Q_PROPERTY( bool showAddButton READ isAddButtonShown WRITE setAddButtonShown )
++
++public:
++    explicit StylesComboPreview(QWidget *parent = 0);
++    ~StylesComboPreview();
++
++    QSize availableSize() const;
++    void setAddButtonShown(bool show);
++    bool isAddButtonShown() const;
++
++    void setPreview(QImage image);
++
++signals:
++    void resized();
++    void newStyleRequested(QString name);
++
++protected:
++    virtual void resizeEvent(QResizeEvent *event);
++    virtual void keyPressEvent(QKeyEvent *event);
++    virtual void focusOutEvent(QFocusEvent *);
++    virtual void paintEvent(QPaintEvent *event);
++
++private slots:
++    void addNewStyle();
++
++private:
++    void init();
++    void updateAddButton();
++
++    bool m_renamingNewStyle;
++    bool m_shouldAddNewStyle;
++
++    QImage m_stylePreview;
++
++    QPushButton *m_addButton;
++};
++
++#endif // STYLESCOMBOPREVIEW_H
+diff --git a/plugins/textshape/dialogs/StylesDelegate.cpp b/plugins/textshape/dialogs/StylesDelegate.cpp
+index d1021f5..3a2dee3 100644
+--- a/plugins/textshape/dialogs/StylesDelegate.cpp
++++ b/plugins/textshape/dialogs/StylesDelegate.cpp
+@@ -1,5 +1,6 @@
+ /* This file is part of the KDE project
+  * Copyright (C) 2011 Casper Boemann <cbo@boemann.dk>
++ * Copyright (C) 2011-2012 Pierre Stirnweiss <pstirnweiss@googlemail.com>
+  *
+  * This library is free software; you can redistribute it and/or
+  * modify it under the terms of the GNU Library General Public
+@@ -19,25 +20,188 @@
+ 
+ #include "StylesDelegate.h"
+ 
++
++#include <QAbstractItemView>
++#include <QColor>
++#include <QEvent>
++#include <QMouseEvent>
+ #include <QPainter>
++#include <QPen>
++#include <QRect>
++#include <QScrollBar>
++#include <QStyle>
++#include <QStyleOptionButton>
++#include <QStyleOptionViewItemV4>
++
++#include <KIcon>
++#include <KDebug>
++
+ 
+ StylesDelegate::StylesDelegate()
+- : QStyledItemDelegate()
++    : QStyledItemDelegate(),
++      m_editButtonPressed(false),
++      m_deleteButtonPressed(false)
+ {
++    m_buttonSize = 16;
++    m_buttonDistance = 2;
+ }
+ 
+-void StylesDelegate::paint(QPainter *painter, const QStyleOptionViewItem &option,
++void StylesDelegate::paint(QPainter *painter, const QStyleOptionViewItem &optionV1,
+                             const QModelIndex &index) const
+ {
+-   if (index.column() == 1) {
+-         painter->fillRect(option.rect, QColor(Qt::red));
++    QStyleOptionViewItemV4 option = optionV1;
++    initStyleOption(&option, index);
++    QStyledItemDelegate::paint(painter, option, index);
+ 
+-   } else {
+-         QStyledItemDelegate::paint(painter, option, index);
+-   }
++    //the following is needed to find out if the view has vertical scrollbars. If there is no view just paint and do not attempt to draw the control buttons.
++    //this is needed because it seems that the option.rect given does not exclude the vertical scrollBar. This means that we can draw the button in an area that is going to be covered by the vertical scrollBar.
++    const QAbstractItemView *view = static_cast<const QAbstractItemView*>(option.widget);
++    if (!view){
++        return;
++    }
++    QScrollBar *scrollBar = view->verticalScrollBar();
++    int scrollBarWidth = 0;
++    if (scrollBar->isVisible()) {
++        scrollBarWidth = scrollBar->width();
++    }
++
++    if (!index.isValid() || !(option.state & QStyle::State_MouseOver)) {
++    return;
++    }
++    // Delete style button.
++    int dx1 = option.rect.width() - qMin(option.rect.height()-2, m_buttonSize) - m_buttonSize - m_buttonDistance -2;
++    int dy1 = 1 + (option.rect.height()-qMin(option.rect.height(), m_buttonSize))/2;
++    int dx2 = -m_buttonSize - m_buttonDistance -2;
++    int dy2 = -1 -(option.rect.height()-qMin(option.rect.height(), m_buttonSize))/2;
++/* TODO: when we can safely delete styles, re-enable this
++    QStyleOptionButton optDel;
++    if (!m_deleteButtonPressed) {
++        optDel.state |= QStyle::State_Enabled;
++    }
++    optDel.icon = KIcon("edit-delete");
++    optDel.features |= QStyleOptionButton::Flat;
++    optDel.rect = option.rect.adjusted(dx1 - scrollBarWidth, dy1, dx2 - scrollBarWidth, dy2);
++    view->style()->drawControl(QStyle::CE_PushButton, &optDel, painter, 0);
++*/
++    // Open style manager dialog button.
++    dx1 = option.rect.width() - qMin(option.rect.height()-2, m_buttonSize) -2;
++    dy1 = 1 + (option.rect.height()-qMin(option.rect.height(), m_buttonSize))/2;
++    dx2 = -2;
++    dy2 = -1 -(option.rect.height()-qMin(option.rect.height(), m_buttonSize))/2;
++    QStyleOptionButton optEdit;
++    if (!m_editButtonPressed) {
++        optEdit.state |= QStyle::State_Enabled;
++    }
++    optEdit.icon = KIcon("document-properties");
++    optEdit.features |= QStyleOptionButton::Flat;
++    optEdit.rect = option.rect.adjusted(dx1 - scrollBarWidth, dy1, dx2 - scrollBarWidth, dy2);
++    view->style()->drawControl(QStyle::CE_PushButton, &optEdit, painter, 0);
+ }
+ 
+ QSize StylesDelegate::sizeHint(const QStyleOptionViewItem &option, const QModelIndex &index) const
+ {
+-    return QSize(250,48);
++    Q_UNUSED(index);
++    Q_UNUSED(option);
++    return QSize(250, 48);
++}
++
++bool StylesDelegate::editorEvent(QEvent *event, QAbstractItemModel *model, const QStyleOptionViewItem &optionV1, const QModelIndex &index)
++{
++    Q_UNUSED(model);
++    QStyleOptionViewItemV4 option = optionV1;
++    initStyleOption(&option, index);
++
++    //the following is needed to find out if the view has vertical scrollbars. If not just paint and do not attempt to draw the control buttons.
++    //this is needed because it seems that the option.rect given does not exclude the vertical scrollBar. This means that we can draw the button in an area that is going to be covered by the vertical scrollBar.
++
++    const QAbstractItemView *view = static_cast<const QAbstractItemView*>(option.widget);
++    if (!view){
++        return false;
++    }
++    QScrollBar *scrollBar = view->verticalScrollBar();
++    int scrollBarWidth = 0;
++    if (scrollBar->isVisible()) {
++        scrollBarWidth = scrollBar->width();
++    }
++
++    if (event->type() == QEvent::MouseButtonPress) {
++        QMouseEvent *mouseEvent = static_cast<QMouseEvent*>(event);
++        int dx1 = option.rect.width()- qMin(option.rect.height()-2, m_buttonSize) - m_buttonSize - m_buttonDistance -2;
++        int dy1 = 1 + (option.rect.height()-qMin(option.rect.height(), m_buttonSize))/2;
++        int dx2 = - m_buttonSize - m_buttonDistance -2;
++        int dy2 = -1 -(option.rect.height()-qMin(option.rect.height(), m_buttonSize))/2;
++/*TODO: when we can safely delete styles, re-enable this
++        QRect delRect = option.rect.adjusted(dx1 - scrollBarWidth, dy1, dx2 - scrollBarWidth, dy2);
++        if (delRect.contains(mouseEvent->pos())) {
++            m_deleteButtonPressed = true;
++        }
++        else {
++            m_deleteButtonPressed = false;
++        }
++*/
++        dx1 = option.rect.width() - qMin(option.rect.height()-2, m_buttonSize) -2;
++        dy1 = 1 + (option.rect.height()-qMin(option.rect.height(), m_buttonSize))/2;
++        dx2 = -2;
++        dy2 = -1 -(option.rect.height()-qMin(option.rect.height(), m_buttonSize))/2;
++        QRect editRect = option.rect.adjusted(dx1 - scrollBarWidth, dy1, dx2 - scrollBarWidth, dy2);
++        if (editRect.contains(mouseEvent->pos())){
++            m_editButtonPressed = true;
++        }
++        else {
++            m_editButtonPressed = false;
++        }
++        emit needsUpdate(index);
++    }
++    if (event->type() == QEvent::MouseButtonRelease) {
++        m_deleteButtonPressed = false;
++        m_editButtonPressed = false;
++        emit needsUpdate(index);
++        QMouseEvent *mouseEvent = static_cast<QMouseEvent*>(event);
++        int dx1 = option.rect.width() - qMin(option.rect.height()-2, m_buttonSize) - m_buttonSize - m_buttonDistance -2;
++        int dy1 = 1 + (option.rect.height()-qMin(option.rect.height(), m_buttonSize))/2;
++        int dx2 = - m_buttonSize - m_buttonDistance -2;
++        int dy2 = -1 -(option.rect.height()-qMin(option.rect.height(), m_buttonSize))/2;
++/*TODO: when we can safely delete styles, re-enable this
++        QRect delRect = option.rect.adjusted(dx1 - scrollBarWidth, dy1, dx2 - scrollBarWidth, dy2);
++        if (delRect.contains(mouseEvent->pos())) {
++            emit deleteStyleButtonClicked(index);
++            return true;
++        }
++*/
++        dx1 = option.rect.width() - qMin(option.rect.height()-2, m_buttonSize) -2;
++        dy1 = 1 + (option.rect.height()-qMin(option.rect.height(), m_buttonSize))/2;
++        dx2 = -2;
++        dy2 = -1 -(option.rect.height()-qMin(option.rect.height(), m_buttonSize))/2;
++        QRect editRect = option.rect.adjusted(dx1 - scrollBarWidth, dy1, dx2 - scrollBarWidth, dy2);
++        if (editRect.contains(mouseEvent->pos())){
++            emit styleManagerButtonClicked(index);
++            return true;
++        }
++        emit clickedInItem(index);
++        return false;
++    }
++    if (event->type() == QEvent::MouseMove) {
++        QMouseEvent *mouseEvent = static_cast<QMouseEvent*>(event);
++        int dx1 = option.rect.width() - qMin(option.rect.height()-2, m_buttonSize) - m_buttonSize - m_buttonDistance -2;
++        int dy1 = 1 + (option.rect.height()-qMin(option.rect.height(), m_buttonSize))/2;
++        int dx2 = - m_buttonSize - m_buttonDistance -2;
++        int dy2 = -1 -(option.rect.height()-qMin(option.rect.height(), m_buttonSize))/2;
++/*TODO: when we can safely delete styles, re-enable this
++        QRect delRect = option.rect.adjusted(dx1 - scrollBarWidth, dy1, dx2 - scrollBarWidth, dy2);
++        if (!delRect.contains(mouseEvent->pos())) {
++            m_deleteButtonPressed = false;
++        }
++*/
++        dx1 = option.rect.width() - qMin(option.rect.height()-2, m_buttonSize) -2;
++        dy1 = 1 + (option.rect.height()-qMin(option.rect.height(), m_buttonSize))/2;
++        dx2 = -2;
++        dy2 = -1 -(option.rect.height()-qMin(option.rect.height(), m_buttonSize))/2;
++        QRect editRect = option.rect.adjusted(dx1 - scrollBarWidth, dy1, dx2 - scrollBarWidth, dy2);
++        if (!editRect.contains(mouseEvent->pos())){
++            m_editButtonPressed = false;
++        }
++        emit needsUpdate(index);
++        return false;
++    }
++    return false;
+ }
+diff --git a/plugins/textshape/dialogs/StylesDelegate.h b/plugins/textshape/dialogs/StylesDelegate.h
+index f5d216f..d7d0572 100644
+--- a/plugins/textshape/dialogs/StylesDelegate.h
++++ b/plugins/textshape/dialogs/StylesDelegate.h
+@@ -1,5 +1,6 @@
+ /* This file is part of the KDE project
+  * Copyright (C) 2011 Casper Boemann <cbo@boemann.dk>
++ * Copyright (C) 2011-2012 Pierre Stirnweiss <pstirnweiss@googlemail.com>
+  *
+  * This library is free software; you can redistribute it and/or
+  * modify it under the terms of the GNU Library General Public
+@@ -21,19 +22,36 @@
+ 
+ #include <QStyledItemDelegate>
+ 
+-class KoStyleManager;
+-class KoParagraphStyle;
+-class KoCharacterStyle;
++/** This is an internal class, used for the preview of styles in the dropdown of the @class StylesCombo.
++  * This class is also responsible for drawing and handling the buttons to call the style manager or to delete a style.
++  * NB. Deleting a style is currently not supported, therefore the button has been disabled. */
+ 
+ class StylesDelegate : public QStyledItemDelegate
+ {
+     Q_OBJECT
++
+ public:
+     StylesDelegate();
+ 
+     virtual void paint(QPainter *painter, const QStyleOptionViewItem &option,
+                             const QModelIndex &index) const;
+     virtual QSize sizeHint(const QStyleOptionViewItem &option, const QModelIndex &index) const;
++
++    virtual bool editorEvent(QEvent *event, QAbstractItemModel *model,
++                            const QStyleOptionViewItem &option, const QModelIndex &index);
++
++signals:
++    void styleManagerButtonClicked(QModelIndex index);
++    void deleteStyleButtonClicked(QModelIndex index);
++    void needsUpdate(QModelIndex index);
++    void clickedInItem(QModelIndex index);
++
++private:
++    bool m_editButtonPressed;
++    bool m_deleteButtonPressed;
++
++    int m_buttonSize;
++    int m_buttonDistance;
+ };
+ 
+ #endif
+diff --git a/plugins/textshape/dialogs/StylesModel.cpp b/plugins/textshape/dialogs/StylesModel.cpp
+index 94deb24..3ea3ed0 100644
+--- a/plugins/textshape/dialogs/StylesModel.cpp
++++ b/plugins/textshape/dialogs/StylesModel.cpp
+@@ -1,6 +1,7 @@
+ /* This file is part of the KDE project
+  * Copyright (C) 2008 Thomas Zander <zander@kde.org>
+  * Copyright (C) 2011 Casper Boemann <cbo@boemann.dk>
++ * Copyright (C) 2011-2012 Pierre Stirnweiss <pstirnweiss@googlemail.org>
+  *
+  * This library is free software; you can redistribute it and/or
+  * modify it under the terms of the GNU Library General Public
+@@ -18,44 +19,37 @@
+  * Boston, MA 02110-1301, USA.
+  */
+ #include "StylesModel.h"
+-#include "TextTool.h"
+ 
+-#include <QSet>
+-#include <QDebug>
+-#include <QSignalMapper>
+-#include <QTextLayout>
+-#include <QTextBlock>
+-
+-#include <KoStyleManager.h>
+ #include <KoStyleThumbnailer.h>
++#include <KoStyleManager.h>
+ #include <KoParagraphStyle.h>
+ #include <KoCharacterStyle.h>
+ 
++#include <QSignalMapper>
++#include <QList>
++#include <QImage>
++
+ #include <KIcon>
+-#include <KoTextBlockData.h>
+-#include <KoParagraphStyle.h>
+-#include <KoInlineTextObjectManager.h>
+-#include <KoTextDocumentLayout.h>
+-#include <KoZoomHandler.h>
+ 
+ #include <KDebug>
+ 
+-#include <QTextLayout>
+-
+-
+-StylesModel::StylesModel(KoStyleManager *manager, bool paragraphMode, QObject *parent)
++StylesModel::StylesModel(KoStyleManager *manager, Type modelType, QObject *parent)
+     : QAbstractListModel(parent),
+       m_styleManager(0),
+       m_styleThumbnailer(0),
+       m_currentParagraphStyle(0),
+-      m_currentCharacterStyle(0),
+-      m_pureParagraphStyle(true),
+-      m_pureCharacterStyle(true),
+-      m_paragraphMode(paragraphMode),
+-      m_styleMapper(new QSignalMapper(this)),
+-      m_tmpTextShape(0)
+-{
++      m_defaultCharacterStyle(0),
++      m_modelType(modelType),
++      m_styleMapper(new QSignalMapper(this)){
+     setStyleManager(manager);
++    //Create a default characterStyle for the preview of "As paragraph" character style
++    if (m_modelType == StylesModel::CharacterStyle) {
++        m_defaultCharacterStyle = new KoCharacterStyle();
++        m_defaultCharacterStyle->setStyleId(-1);
++        m_defaultCharacterStyle->setName(QString("As paragraph"));
++        m_defaultCharacterStyle->setFontPointSize(12);
++    }
++
+     m_paragIcon = KIcon("kotext-paragraph");
+     m_charIcon = KIcon("kotext-character");
+     connect(m_styleMapper, SIGNAL(mapped(int)), this, SLOT(updateName(int)));
+@@ -63,7 +57,8 @@ StylesModel::StylesModel(KoStyleManager *manager, bool paragraphMode, QObject *p
+ 
+ StylesModel::~StylesModel()
+ {
+-    delete m_tmpTextShape;
++    delete m_currentParagraphStyle;
++    delete m_defaultCharacterStyle;
+ }
+ 
+ QModelIndex StylesModel::index(int row, int column, const QModelIndex &parent) const
+@@ -92,29 +87,40 @@ QVariant StylesModel::data(const QModelIndex &index, int role) const
+     if (!index.isValid())
+         return QVariant();
+ 
+-    int id = (int) index.internalId();
+-    switch (role) {
++    int id = (int)index.internalId();
++    switch (role){
+     case Qt::DisplayRole: {
+         return QVariant();
+-        KoParagraphStyle *paragStyle = m_styleManager->paragraphStyle(id);
+-        if (paragStyle)
+-            return paragStyle->name();
+-        KoCharacterStyle *characterStyle =  m_styleManager->characterStyle(id);
+-        if (characterStyle)
+-            return characterStyle->name();
+-        break;
+     }
+     case Qt::DecorationRole: {
+         if (!m_styleThumbnailer) {
+             return QPixmap();
+         }
+-        KoParagraphStyle *paragStyle = m_styleManager->paragraphStyle(id);
+-        if (paragStyle) {
+-            return m_styleThumbnailer->thumbnail(paragStyle);
++        if (m_modelType == StylesModel::ParagraphStyle) {
++            KoParagraphStyle *paragStyle = m_styleManager->paragraphStyle(id);
++            if (paragStyle) {
++                return m_styleThumbnailer->thumbnail(paragStyle);
++            }
+         }
+-        KoCharacterStyle *characterStyle =  m_styleManager->characterStyle(id);
+-        if (characterStyle) {
+-            return m_styleThumbnailer->thumbnail(characterStyle);
++        else {
++            KoCharacterStyle *usedStyle = 0;
++            if (id == -1) {
++                usedStyle = static_cast<KoCharacterStyle*>(m_currentParagraphStyle);
++                if (!usedStyle) {
++                    usedStyle = m_defaultCharacterStyle;
++                }
++                usedStyle->setName(QString("As paragraph"));
++                if (usedStyle->styleId() >= 0) { //if the styleId is -1, we are using the default character style
++                    usedStyle->setStyleId(-usedStyle->styleId()); //this style is not managed by the styleManager but its styleId will be used in the thumbnail cache as part of the key.
++                }
++                return m_styleThumbnailer->thumbnail(usedStyle);
++            }
++            else {
++                usedStyle = m_styleManager->characterStyle(id);
++                if (usedStyle) {
++                    return m_styleThumbnailer->thumbnail(usedStyle);
++                }
++            }
+         }
+         break;
+     }
+@@ -130,20 +136,16 @@ Qt::ItemFlags StylesModel::flags(const QModelIndex &index) const
+     return (Qt::ItemIsSelectable | Qt::ItemIsEnabled);
+ }
+ 
+-void StylesModel::setCurrentParagraphStyle(int styleId, bool unchanged)
+-{
+-    if (m_currentParagraphStyle == styleId && unchanged == m_pureParagraphStyle)
+-        return;
+-    m_currentParagraphStyle = styleId;
+-    m_pureParagraphStyle = unchanged;
+-}
+-
+-void StylesModel::setCurrentCharacterStyle(int styleId, bool unchanged)
++void StylesModel::setCurrentParagraphStyle(int styleId)
+ {
+-    if (m_currentCharacterStyle == styleId && unchanged == m_pureCharacterStyle)
+-        return;
+-    m_currentCharacterStyle = styleId;
+-    m_pureCharacterStyle = unchanged;
++    if (m_currentParagraphStyle == m_styleManager->paragraphStyle(styleId) || !m_styleManager->paragraphStyle(styleId)) {
++        return; //TODO do we create a default paragraphStyle? use the styleManager default?
++    }
++    if (m_currentParagraphStyle) {
++        delete m_currentParagraphStyle;
++        m_currentParagraphStyle = 0;
++    }
++    m_currentParagraphStyle = m_styleManager->paragraphStyle(styleId)->clone();
+ }
+ 
+ KoParagraphStyle *StylesModel::paragraphStyleForIndex(const QModelIndex &index) const
+@@ -154,7 +156,8 @@ KoParagraphStyle *StylesModel::paragraphStyleForIndex(const QModelIndex &index)
+ QModelIndex StylesModel::indexForParagraphStyle(const KoParagraphStyle &style) const
+ {
+     if (&style) {
+-        return createIndex(m_styleList.indexOf(style.styleId()), 0, style.styleId());;
++        QModelIndex index = createIndex(m_styleList.indexOf(style.styleId()), 0, style.styleId());
++        return index;
+     }
+     else {
+         return QModelIndex();
+@@ -176,6 +179,40 @@ QModelIndex StylesModel::indexForCharacterStyle(const KoCharacterStyle &style) c
+     }
+ }
+ 
++QImage StylesModel::stylePreview(int row, QSize size)
++{
++    Q_ASSERT(m_styleManager);
++    Q_ASSERT(m_styleThumbnailer);
++    if (m_modelType == StylesModel::ParagraphStyle) {
++        KoParagraphStyle *usedStyle = 0;
++        usedStyle = m_styleManager->paragraphStyle(index(row).internalId());
++        if (usedStyle) {
++            return m_styleThumbnailer->thumbnail(usedStyle, size);
++        }
++    }
++    else {
++        KoCharacterStyle *usedStyle = 0;
++        if (index(row).internalId() == -1) {
++            usedStyle = static_cast<KoCharacterStyle*>(m_currentParagraphStyle);
++            if (!usedStyle) {
++                usedStyle = m_defaultCharacterStyle;
++            }
++            usedStyle->setName(QString("As paragraph"));
++            if (usedStyle->styleId() >= 0) {
++                usedStyle->setStyleId(-usedStyle->styleId()); //this style is not managed by the styleManager but its styleId will be used in the thumbnail cache as part of the key.
++            }
++            return m_styleThumbnailer->thumbnail(usedStyle, size);
++        }
++        else {
++            usedStyle = m_styleManager->characterStyle(index(row).internalId());
++            if (usedStyle) {
++                return m_styleThumbnailer->thumbnail(usedStyle, size);
++            }
++        }
++    }
++    return QImage();
++}
++
+ void StylesModel::setStyleManager(KoStyleManager *sm)
+ {
+     if (sm == m_styleManager)
+@@ -191,12 +228,15 @@ void StylesModel::setStyleManager(KoStyleManager *sm)
+         return;
+     }
+ 
+-    if (m_paragraphMode) {
++    if (m_modelType == StylesModel::ParagraphStyle) {
+         foreach(KoParagraphStyle *style, m_styleManager->paragraphStyles())
+             addParagraphStyle(style);
+         connect(sm, SIGNAL(styleAdded(KoParagraphStyle*)), this, SLOT(addParagraphStyle(KoParagraphStyle*)));
+         connect(sm, SIGNAL(styleRemoved(KoParagraphStyle*)), this, SLOT(removeParagraphStyle(KoParagraphStyle*)));
+     } else {
++        if (m_styleManager->paragraphStyles().count()) {
++            m_styleList.append(-1);
++        }
+         foreach(KoCharacterStyle *style, m_styleManager->characterStyles())
+             addCharacterStyle(style);
+         connect(sm, SIGNAL(styleAdded(KoCharacterStyle*)), this, SLOT(addCharacterStyle(KoCharacterStyle*)));
+@@ -213,16 +253,20 @@ void StylesModel::setStyleThumbnailer(KoStyleThumbnailer *thumbnailer)
+ void StylesModel::addParagraphStyle(KoParagraphStyle *style)
+ {
+     Q_ASSERT(style);
++    beginInsertRows(QModelIndex(), rowCount(QModelIndex()), rowCount(QModelIndex()));
+     m_styleList.append(style->styleId());
+     m_styleMapper->setMapping(style, style->styleId());
+     connect(style, SIGNAL(nameChanged(const QString&)), m_styleMapper, SLOT(map()));
++    endInsertRows();
+ }
+ 
+ // called when the stylemanager adds a style
+ void StylesModel::addCharacterStyle(KoCharacterStyle *style)
+ {
+     Q_ASSERT(style);
++    beginInsertRows(QModelIndex(), rowCount(QModelIndex()), rowCount(QModelIndex()));
+     m_styleList.append(style->styleId());
++    endInsertRows();
+     m_styleMapper->setMapping(style, style->styleId());
+     connect(style, SIGNAL(nameChanged(const QString&)), m_styleMapper, SLOT(map()));
+ }
+@@ -230,15 +274,23 @@ void StylesModel::addCharacterStyle(KoCharacterStyle *style)
+ // called when the stylemanager removes a style
+ void StylesModel::removeParagraphStyle(KoParagraphStyle *style)
+ {
++    int row = m_styleList.indexOf(style->styleId());
++    beginRemoveRows(QModelIndex(), row, row);
+     m_styleMapper->removeMappings(style);
+     disconnect(style, SIGNAL(nameChanged(const QString&)), m_styleMapper, SLOT(map()));
++    m_styleList.removeAt(row);
++    endRemoveRows();
+ }
+ 
+ // called when the stylemanager removes a style
+ void StylesModel::removeCharacterStyle(KoCharacterStyle *style)
+ {
++    int row = m_styleList.indexOf(style->styleId());
++    beginRemoveRows(QModelIndex(), row, row);
+     m_styleMapper->removeMappings(style);
+     disconnect(style, SIGNAL(nameChanged(const QString&)), m_styleMapper, SLOT(map()));
++    m_styleList.removeAt(row);
++    endRemoveRows();
+ }
+ 
+ void StylesModel::updateName(int styleId)
+diff --git a/plugins/textshape/dialogs/StylesModel.h b/plugins/textshape/dialogs/StylesModel.h
+index dbd17b4..0e9fcba 100644
+--- a/plugins/textshape/dialogs/StylesModel.h
++++ b/plugins/textshape/dialogs/StylesModel.h
+@@ -1,6 +1,7 @@
+ /* This file is part of the KDE project
+  * Copyright (C) 2008 Thomas Zander <zander@kde.org>
+  * Copyright (C) 2011 Casper Boemann <cbo@boemann.dk>
++ * Copyright (C) 2011-2012 Pierre Stirnweiss <pstirnweiss@googlemail.org>
+  *
+  * This library is free software; you can redistribute it and/or
+  * modify it under the terms of the GNU Library General Public
+@@ -21,27 +22,39 @@
+ #define MODEL_H
+ 
+ #include <QAbstractListModel>
+-#include <QMultiHash>
+-#include <QIcon>
+-#include <QPixmap>
+-#include <QMap>
++#include <KIcon>
+ 
+ class KoStyleThumbnailer;
+ 
+ class KoStyleManager;
+ class KoParagraphStyle;
+ class KoCharacterStyle;
++
++class QImage;
+ class QSignalMapper;
+-class TextShape;
++class QSize;
++
++/** This class is used to provide widgets (like the @class StylesCombo) the styles available to the document being worked on. The @class StylesModel can be of two types: character styles or paragraph styles type. This allows the widget to ignore the type of style it is handling.
++  * Character styles in ODF can be specified in two ways. First, a named character style, specifying character formatting properties. It is meant to be used on a couple of individual characters. Secondely, a paragraph style also specifies character formatting properties, which are to be considered the default for that particular paragraph.
++  * For this reason, the @class Stylesmodel, when of the type @value characterStyle, do not list the paragraph style names. Only the specific named chracter styles are listed. Additionnaly, as the first item, a virtual style "As paragraph" is provided. Selecting this "style" will set the character properties as specified by the paragraph style currently applied to the selection.
++  * This class requires that a @class KoStyleManager and a @class KoStyleThumbnailer be set. See below methods.
++*/
+ 
+ class StylesModel : public QAbstractListModel
+ {
+     Q_OBJECT
+ 
+ public:
+-    explicit StylesModel(KoStyleManager *styleManager, bool paragraphMode, QObject *parent = 0);
++    enum Type {
++        CharacterStyle,
++        ParagraphStyle
++    };
++
++    explicit StylesModel(KoStyleManager *styleManager, Type modelType, QObject *parent = 0);
+     ~StylesModel();
+ 
++    /** Re-implemented from QAbstractItemModel. */
++
+     virtual QModelIndex index(int row, int column=0, const QModelIndex &parent = QModelIndex()) const;
+ 
+     virtual int rowCount(const QModelIndex &parent) const;
+@@ -50,28 +63,32 @@ public:
+ 
+     virtual Qt::ItemFlags flags(const QModelIndex &index) const;
+ 
++    /** Specific methods of the StylesModel */
++
++    /** Returns the @class KoParagraphStyle corresponding to the specified @param index. */
+     KoParagraphStyle *paragraphStyleForIndex(const QModelIndex &index) const;
++    /** Return a @class QModelIndex for the specified @param style. */
+     QModelIndex indexForParagraphStyle(const KoParagraphStyle &style) const;
+ 
++    /** Returns the @class KoCharacterhStyle corresponding to the specified @param index. */
+     KoCharacterStyle *characterStyleForIndex(const QModelIndex &index) const;
++    /** Return a @class QModelIndex for the specified @param style. */
+     QModelIndex indexForCharacterStyle(const KoCharacterStyle &style) const;
+ 
++    /** Returns a QImage which is a preview of the style specified by @param row of the given @param size.
++      * If size isn't specified, the default size of the given @class KoStyleThumbnailer is used.
++    */
++    QImage stylePreview(int row, QSize size = QSize());
++
++    /** Sets the @class KoStyleManager of the model. Setting this will populate the styles. It is required that a @param manager is set before using the model.
++      * CAUTION: Populating the style will select the first inserted item. If this model is already set on a view, this might cause the view to emit an item selection changed signal.
++    */
+     void setStyleManager(KoStyleManager *manager);
++    /** Sets the @class KoStyleThumbnailer of the model. It is required that a @param thumbnailer is set before using the model. */
+     void setStyleThumbnailer(KoStyleThumbnailer *thumbnailer);
+ 
+-public slots:
+-    /**
+-        Sets the paragraph style that is to be marked as the 'active' one.
+-        @param styleId the id from KoParagraphStyle::styleId()
+-        @param unchanged if true the icon will display the paragraph style in the text has no local modifications.
+-    */
+-    void setCurrentParagraphStyle(int styleId, bool unchanged);
+-    /**
+-        Sets the character style that is to be marked as the 'active' one.
+-        @param styleId the id from KoCharacterStyle::styleId()
+-        @param unchanged if true the icon will display the character style in the text has no local modifications.
+-    */
+-    void setCurrentCharacterStyle(int styleId, bool unchanged);
++    /** Specifies which paragraph style is currently the active one (on the current paragraph). This is used in order to properly preview the "As paragraph" virtual character style. */
++    void setCurrentParagraphStyle(int styleId);
+ 
+ private slots:
+     void addParagraphStyle(KoParagraphStyle*);
+@@ -87,16 +104,13 @@ private:
+     KoStyleManager *m_styleManager;
+     KoStyleThumbnailer *m_styleThumbnailer;
+ 
+-    int m_currentParagraphStyle;
+-    int m_currentCharacterStyle;
+-    bool m_pureParagraphStyle;
+-    bool m_pureCharacterStyle;
+-    bool m_paragraphMode;
++    KoParagraphStyle *m_currentParagraphStyle;
++    KoCharacterStyle *m_defaultCharacterStyle;
++    Type m_modelType;
+ 
+-    QIcon m_paragIcon, m_charIcon;
++    KIcon m_paragIcon, m_charIcon;
+ 
+     QSignalMapper *m_styleMapper;
+-    TextShape *m_tmpTextShape;
+ };
+ 
+ #endif
+diff --git a/plugins/textshape/dialogs/StylesWidget.cpp b/plugins/textshape/dialogs/StylesWidget.cpp
+index 4f31a01..33be92e 100644
+--- a/plugins/textshape/dialogs/StylesWidget.cpp
++++ b/plugins/textshape/dialogs/StylesWidget.cpp
+@@ -21,9 +21,9 @@
+ #include "StylesDelegate.h"
+ #include "ParagraphGeneral.h"
+ #include "CharacterGeneral.h"
++#include <KoStyleThumbnailer.h>
+ 
+ #include <KoStyleManager.h>
+-#include <KoStyleThumbnailer.h>
+ #include <KoCharacterStyle.h>
+ #include <KoParagraphStyle.h>
+ 
+@@ -42,7 +42,7 @@ StylesWidget::StylesWidget(QWidget *parent, bool paragraphMode, Qt::WindowFlags
+         : QFrame(parent, f),
+         m_styleManager(0),
+           m_styleThumbnailer(0),
+-        m_stylesModel(new StylesModel(0, paragraphMode)),
++        m_stylesModel(new StylesModel(0, StylesModel::ParagraphStyle)),
+         m_stylesDelegate(new StylesDelegate()),
+         m_blockSignals(false),
+         m_isHovered(false)
+@@ -52,7 +52,7 @@ StylesWidget::StylesWidget(QWidget *parent, bool paragraphMode, Qt::WindowFlags
+     m_stylesModel->setStyleThumbnailer(m_styleThumbnailer);
+     widget.setupUi(this);
+     widget.stylesView->setModel(m_stylesModel);
+-    widget.stylesView->setItemDelegate(m_stylesDelegate);
++//    widget.stylesView->setItemDelegate(m_stylesDelegate);
+ 
+     if (paragraphMode) {
+         connect(widget.stylesView, SIGNAL(clicked(const QModelIndex&)), this, SLOT(applyParagraphStyle()));
+@@ -103,7 +103,7 @@ void StylesWidget::setCurrentFormat(const QTextBlockFormat &format)
+     }
+ 
+     m_blockSignals = true;
+-    m_stylesModel->setCurrentParagraphStyle(id, unchanged);
++//    m_stylesModel->setCurrentParagraphStyle(id, unchanged);
+     m_blockSignals = false;
+     widget.stylesView->setCurrentIndex(m_stylesModel->indexForParagraphStyle(*usedStyle));
+ }
+@@ -134,7 +134,7 @@ void StylesWidget::setCurrentFormat(const QTextCharFormat &format)
+     }
+ 
+     m_blockSignals = true;
+-    m_stylesModel->setCurrentCharacterStyle(id, unchanged);
++//    m_stylesModel->setCurrentCharacterStyle(id, unchanged);
+     m_blockSignals = false;
+     widget.stylesView->setCurrentIndex(m_stylesModel->indexForCharacterStyle(*usedStyle));
+ }
+diff --git a/plugins/textshape/dialogs/TableOfContentsStyleModel.cpp b/plugins/textshape/dialogs/TableOfContentsStyleModel.cpp
+index 48ee7c3..6884c46 100644
+--- a/plugins/textshape/dialogs/TableOfContentsStyleModel.cpp
++++ b/plugins/textshape/dialogs/TableOfContentsStyleModel.cpp
+@@ -20,7 +20,7 @@
+ #include "TableOfContentsStyleModel.h"
+ 
+ #include "KoStyleManager.h"
+-#include "KoStyleThumbnailer.h"
++#include <KoStyleThumbnailer.h>
+ #include "KoParagraphStyle.h"
+ #include "ToCBibGeneratorInfo.h"
+ #include "KoTableOfContentsGeneratorInfo.h"
diff --git a/plugins/textshape/CMakeLists.txt b/plugins/textshape/CMakeLists.txt
index fad7c04..60979db 100644
--- a/plugins/textshape/CMakeLists.txt
+++ b/plugins/textshape/CMakeLists.txt
@@ -35,6 +35,8 @@ SET ( textshape_SRCS
 
     dialogs/StylesWidget.cpp
     dialogs/SpecialButton.cpp
+    dialogs/StylesCombo.cpp
+    dialogs/StylesComboPreview.cpp
     dialogs/SimpleCharacterWidget.cpp
     dialogs/SimpleParagraphWidget.cpp
     dialogs/SimpleTableWidget.cpp
diff --git a/plugins/textshape/TextTool.cpp b/plugins/textshape/TextTool.cpp
index f6822bd..92ff76b 100644
--- a/plugins/textshape/TextTool.cpp
+++ b/plugins/textshape/TextTool.cpp
@@ -2,7 +2,7 @@
  * Copyright (C) 2006-2010 Thomas Zander <zander@kde.org>
  * Copyright (C) 2008 Thorsten Zachmann <zachmann@kde.org>
  * Copyright (C) 2008 Girish Ramakrishnan <girish@forwardbias.in>
- * Copyright (C) 2008 Pierre Stirnweiss <pierre.stirnweiss_calligra@gadz.org>
+ * Copyright (C) 2008, 2012 Pierre Stirnweiss <pstirnweiss@googlemail.org>
  * Copyright (C) 2009 KO GmbH <cbo@kogmbh.com>
  * Copyright (C) 2011 Mojtaba Shahi Senobari <mojtaba.shahi3000@gmail.com>
  *
@@ -818,6 +818,7 @@ void TextTool::setShapeData(KoTextShapeData *data)
     if (docChanged) {
         if (!m_textEditor.isNull()) {
             disconnect(m_textEditor.data(), SIGNAL(isBidiUpdated()), this, SLOT(isBidiUpdated()));
+            disconnect(m_textEditor.data(), SIGNAL(textFormatChanged()), this, SLOT(updateActions()));
         }
         m_textEditor = KoTextDocument(m_textShapeData->document()).textEditor();
         Q_ASSERT(m_textEditor.data());
@@ -835,6 +836,7 @@ void TextTool::setShapeData(KoTextShapeData *data)
         }
 
         connect(m_textEditor.data(), SIGNAL(isBidiUpdated()), this, SLOT(isBidiUpdated()));
+        connect(m_textEditor.data(), SIGNAL(textFormatChanged()), this, SLOT(updateActions()));
     }
     m_textEditor.data()->updateDefaultTextDirection(m_textShapeData->pageDirection());
 }
@@ -1329,8 +1331,9 @@ void TextTool::keyReleaseEvent(QKeyEvent *event)
 void TextTool::updateActions()
 {
     KoTextEditor *textEditor = m_textEditor.data();
-    if (textEditor == 0)
+    if (textEditor == 0) {
         return;
+    }
     m_allowActions = false;
 
     //Update the characterStyle related GUI elements
@@ -1394,9 +1397,10 @@ void TextTool::updateActions()
 
     m_allowActions = true;
 
+    ///TODO if selection contains several different format
+    emit blockChanged(textEditor->block());
     emit charFormatChanged(cf);
     emit blockFormatChanged(bf);
-    emit blockChanged(textEditor->block());
 }
 
 void TextTool::updateStyleManager()
@@ -1412,8 +1416,6 @@ void TextTool::updateStyleManager()
 
 void TextTool::activate(ToolActivation toolActivation, const QSet<KoShape*> &shapes)
 {
-    kDebug();
-
     Q_UNUSED(toolActivation);
     m_caretTimer.start();
     m_caretTimerState = true;
@@ -1437,14 +1439,13 @@ void TextTool::activate(ToolActivation toolActivation, const QSet<KoShape*> &sha
     rect = m_textShape->absoluteTransformation(0).mapRect(rect);
     v.setValue(rect);
     canvas()->resourceManager()->setResource(KoCanvasResourceManager::ActiveRange, v);
-
     setShapeData(static_cast<KoTextShapeData*>(m_textShape->userData()));
     useCursor(Qt::IBeamCursor);
 
+    updateStyleManager();
     repaintSelection();
     updateSelectionHandler();
     updateActions();
-    updateStyleManager();
     if (m_specialCharacterDocker)
         m_specialCharacterDocker->setEnabled(true);
     readConfig();
@@ -1452,8 +1453,6 @@ void TextTool::activate(ToolActivation toolActivation, const QSet<KoShape*> &sha
 
 void TextTool::deactivate()
 {
-    kDebug();
-
     m_caretTimer.stop();
     m_caretTimerState = false;
     repaintCaret();
@@ -1586,14 +1585,24 @@ QList<QWidget *> TextTool::createOptionWidgets()
     QList<QWidget *> widgets;
     SimpleCharacterWidget *scw = new SimpleCharacterWidget(this, 0);
     SimpleParagraphWidget *spw = new SimpleParagraphWidget(this, 0);
+    if (m_textEditor.data()) {
+        //initialise the char- and par- widgets with the current block and formats.
+        scw->setCurrentBlockFormat(m_textEditor.data()->blockFormat());
+        scw->setCurrentFormat(m_textEditor.data()->charFormat());
+        spw->setCurrentBlock(m_textEditor.data()->block());
+        spw->setCurrentFormat(m_textEditor.data()->blockFormat());
+    }
     SimpleTableWidget *stw = new SimpleTableWidget(this, 0);
     SimpleInsertWidget *siw = new SimpleInsertWidget(this, 0);
 
     // Connect to/with simple character widget (docker)
     connect(this, SIGNAL(styleManagerChanged(KoStyleManager *)), scw, SLOT(setStyleManager(KoStyleManager *)));
     connect(this, SIGNAL(charFormatChanged(QTextCharFormat)), scw, SLOT(setCurrentFormat(QTextCharFormat)));
+    connect(this, SIGNAL(blockFormatChanged(QTextBlockFormat)), scw, SLOT(setCurrentBlockFormat(QTextBlockFormat)));
     connect(scw, SIGNAL(doneWithFocus()), this, SLOT(returnFocusToCanvas()));
     connect(scw, SIGNAL(characterStyleSelected(KoCharacterStyle *)), this, SLOT(setStyle(KoCharacterStyle*)));
+    connect(scw, SIGNAL(newStyleRequested(QString)), this, SLOT(createStyleFromCurrentCharFormat(QString)));
+    connect(scw, SIGNAL(showStyleManager(int)), this, SLOT(showStyleManager()));
 
 
     // Connect to/with simple paragraph widget (docker)
@@ -1602,6 +1611,8 @@ QList<QWidget *> TextTool::createOptionWidgets()
     connect(this, SIGNAL(blockFormatChanged(QTextBlockFormat)), spw, SLOT(setCurrentFormat(QTextBlockFormat)));
     connect(spw, SIGNAL(doneWithFocus()), this, SLOT(returnFocusToCanvas()));
     connect(spw, SIGNAL(paragraphStyleSelected(KoParagraphStyle *)), this, SLOT(setStyle(KoParagraphStyle*)));
+    connect(spw, SIGNAL(newStyleRequested(QString)), this, SLOT(createStyleFromCurrentBlockFormat(QString)));
+    connect(spw, SIGNAL(showStyleManager(int)), this, SLOT(showStyleManager()));
 
     // Connect to/with simple table widget (docker)
     connect(this, SIGNAL(styleManagerChanged(KoStyleManager *)), stw, SLOT(setStyleManager(KoStyleManager *)));
@@ -1612,8 +1623,9 @@ QList<QWidget *> TextTool::createOptionWidgets()
     connect(siw, SIGNAL(insertTableQuick(int, int)), this, SLOT(insertTableQuick(int, int)));
 
     updateStyleManager();
-    if (m_textShape)
+    if (m_textShape) {
         updateActions();
+    }
     scw->setWindowTitle(i18n("Character"));
     widgets.append(scw);
     spw->setWindowTitle(i18n("Paragraph"));
@@ -1791,15 +1803,24 @@ void TextTool::insertIndexMarker()
 
 void TextTool::setStyle(KoCharacterStyle *style)
 {
-    m_textEditor.data()->setStyle(style);
-    emit charFormatChanged(m_textEditor.data()->charFormat());
+    KoCharacterStyle *charStyle;
+    //if the given KoCharacterStyle is null, set the KoParagraphStyle character properties
+    if (!style){
+        charStyle = static_cast<KoCharacterStyle*>(KoTextDocument(m_textShapeData->document()).styleManager()->paragraphStyle(m_textEditor.data()->blockFormat().intProperty(KoParagraphStyle::StyleId)));
+    }
+    else {
+        charStyle = style;
+    }
+    if (charStyle) {
+        m_textEditor.data()->setStyle(charStyle);
+        updateActions();
+    }
 }
 
 void TextTool::setStyle(KoParagraphStyle *style)
 {
     m_textEditor.data()->setStyle(style);
-    emit blockFormatChanged(m_textEditor.data()->blockFormat());
-    emit charFormatChanged(m_textEditor.data()->charFormat());
+    updateActions();
 }
 
 void TextTool::insertTable()
@@ -2087,6 +2108,29 @@ void TextTool::shapeDataRemoved()
     }
 }
 
+void TextTool::createStyleFromCurrentBlockFormat(QString name)
+{
+    KoTextDocument document(m_textShapeData->document());
+    KoStyleManager *styleManager = document.styleManager();
+    KoParagraphStyle *paragraphStyle = new KoParagraphStyle(m_textEditor.data()->blockFormat(), m_textEditor.data()->charFormat());
+    paragraphStyle->setName(name);
+    styleManager->add(paragraphStyle);
+    m_textEditor.data()->setStyle(paragraphStyle);
+    emit charFormatChanged(m_textEditor.data()->charFormat());
+    emit blockFormatChanged(m_textEditor.data()->blockFormat());
+}
+
+void TextTool::createStyleFromCurrentCharFormat(QString name)
+{
+    KoTextDocument document(m_textShapeData->document());
+    KoStyleManager *styleManager = document.styleManager();
+    KoCharacterStyle *characterStyle = new KoCharacterStyle(m_textEditor.data()->charFormat());
+    characterStyle->setName(name);
+    styleManager->add(characterStyle);
+    m_textEditor.data()->setStyle(characterStyle);
+    emit charFormatChanged(m_textEditor.data()->charFormat());
+}
+
 // ---------- editing plugins methods.
 void TextTool::editingPluginEvents()
 {
diff --git a/plugins/textshape/TextTool.h b/plugins/textshape/TextTool.h
index f8de126..e9a5090 100644
--- a/plugins/textshape/TextTool.h
+++ b/plugins/textshape/TextTool.h
@@ -3,6 +3,7 @@
  * Copyright (C) 2008 Thorsten Zachmann <zachmann@kde.org>
  * Copyright (C) 2009 KO GmbH <cbo@kogmbh.com>
  * Copyright (C) 2011 Mojtaba Shahi Senobari <mojtaba.shahi3000@gmail.com>
+ * Copyright (C) 2008, 2012 Pierre Stirnweiss <pstirnweiss@googlemail.org>
  *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Library General Public
@@ -286,16 +287,20 @@ private slots:
 
     void ensureCursorVisible(bool moveView = true);
 
+    void createStyleFromCurrentBlockFormat(QString name);
+    void createStyleFromCurrentCharFormat(QString name);
+
     void testSlot(bool);
 
     /// change block text direction
     void textDirectionChanged();
 
+    void updateActions();
+
 private:
     void repaintCaret();
     void repaintSelection();
     KoPointedAt hitTest(const QPointF & point) const;
-    void updateActions();
     void updateStyleManager();
     void updateSelectedShape(const QPointF &point);
     void updateSelectionHandler();
diff --git a/plugins/textshape/dialogs/SimpleCharacterWidget.cpp b/plugins/textshape/dialogs/SimpleCharacterWidget.cpp
index 6b2bb66..f78d9ec 100644
--- a/plugins/textshape/dialogs/SimpleCharacterWidget.cpp
+++ b/plugins/textshape/dialogs/SimpleCharacterWidget.cpp
@@ -1,6 +1,7 @@
 /* This file is part of the KDE project
  * Copyright (C) 2007, 2008, 2010 Thomas Zander <zander@kde.org>
  * Copyright (C) 2009-2010 Casper Boemann <cbo@boemann.dk>
+ * Copyright (C) 2011-2012 Pierre Stirnweiss <pstirnweiss@googlemail.com>
  *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Library General Public
@@ -17,20 +18,21 @@
  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
  * Boston, MA 02110-1301, USA.
  */
+
 #include "SimpleCharacterWidget.h"
 #include "TextTool.h"
 #include "../commands/ChangeListCommand.h"
-#include "StylesWidget.h"
-#include "SpecialButton.h"
+#include "StylesModel.h"
+#include <KoStyleThumbnailer.h>
 
 #include <KAction>
 #include <KSelectAction>
 #include <KoTextBlockData.h>
 #include <KoCharacterStyle.h>
+#include <KoParagraphStyle.h>
 #include <KoInlineTextObjectManager.h>
 #include <KoTextDocumentLayout.h>
 #include <KoZoomHandler.h>
-#include <KoStyleThumbnailer.h>
 #include <KoStyleManager.h>
 
 #include <KDebug>
@@ -39,10 +41,13 @@
 #include <QComboBox>
 
 SimpleCharacterWidget::SimpleCharacterWidget(TextTool *tool, QWidget *parent)
-        : QWidget(parent),
-        m_blockSignals(false),
-        m_comboboxHasBidiItems(false),
-        m_tool(tool)
+    : QWidget(parent),
+      m_styleManager(0),
+      m_blockSignals(false),
+      m_comboboxHasBidiItems(false),
+      m_tool(tool),
+      m_thumbnailer(new KoStyleThumbnailer()),
+      m_stylesModel(new StylesModel(0, StylesModel::CharacterStyle))
 {
     widget.setupUi(this);
     widget.bold->setDefaultAction(tool->action("format_bold"));
@@ -78,46 +83,79 @@ SimpleCharacterWidget::SimpleCharacterWidget(TextTool *tool, QWidget *parent)
 
     widget.fontsFrame->setColumnStretch(0,1);
 
-    m_stylePopup = new StylesWidget(this, false, Qt::Popup);
-    m_stylePopup->setFrameShape(QFrame::StyledPanel);
-    m_stylePopup->setFrameShadow(QFrame::Raised);
-    widget.charFrame->setStylesWidget(m_stylePopup);
-
-    connect(m_stylePopup, SIGNAL(characterStyleSelected(KoCharacterStyle *)), this, SIGNAL(characterStyleSelected(KoCharacterStyle *)));
-    connect(m_stylePopup, SIGNAL(characterStyleSelected(KoCharacterStyle *)), this, SIGNAL(doneWithFocus()));
-    connect(m_stylePopup, SIGNAL(characterStyleSelected(KoCharacterStyle *)), this, SLOT(hidePopup()));
+    m_stylesModel->setStyleThumbnailer(m_thumbnailer);
+    widget.characterStyleCombo->setStylesModel(m_stylesModel);
+    connect(widget.characterStyleCombo, SIGNAL(selectionChanged(int)), this, SLOT(styleSelected(int)));
+    connect(widget.characterStyleCombo, SIGNAL(newStyleRequested(QString)), this, SIGNAL(newStyleRequested(QString)));
+    connect(widget.characterStyleCombo, SIGNAL(newStyleRequested(QString)), this, SIGNAL(doneWithFocus()));
+    connect(widget.characterStyleCombo, SIGNAL(showStyleManager(int)), this, SLOT(slotShowStyleManager(int)));
 
-    m_thumbnailer = new KoStyleThumbnailer();
 }
 
 SimpleCharacterWidget::~SimpleCharacterWidget()
 {
+    //the model is set on the comboBox which takes ownership
     delete m_thumbnailer;
 }
 
 void SimpleCharacterWidget::setStyleManager(KoStyleManager *sm)
 {
     m_styleManager = sm;
-    m_stylePopup->setStyleManager(sm);
-}
-
-void SimpleCharacterWidget::hidePopup()
-{
-    widget.charFrame->hidePopup();
+    //we want to disconnect this before setting the stylemanager. Populating the model apparently selects the first inserted item. We don't want this to actually set a new style.
+    disconnect(widget.characterStyleCombo, SIGNAL(selectionChanged(int)), this, SLOT(styleSelected(int)));
+    m_stylesModel->setStyleManager(sm);
+    connect(widget.characterStyleCombo, SIGNAL(selectionChanged(int)), this, SLOT(styleSelected(int)));
 }
 
 void SimpleCharacterWidget::setCurrentFormat(const QTextCharFormat& format)
 {
-    if (format == m_currentCharFormat)
+    if (!m_styleManager || format == m_currentCharFormat) {
         return;
+    }
     m_currentCharFormat = format;
 
-    int id = m_currentCharFormat.intProperty(KoCharacterStyle::StyleId);
-    KoCharacterStyle *style(m_styleManager->characterStyle(id));
+    KoCharacterStyle *style(m_styleManager->characterStyle(m_currentCharFormat.intProperty(KoCharacterStyle::StyleId)));
+    bool useParagraphStyle = false;
+    if (!style) {
+        style = static_cast<KoCharacterStyle*>(m_styleManager->paragraphStyle(m_currentCharFormat.intProperty(KoParagraphStyle::StyleId)));
+        useParagraphStyle = true;
+    }
     if (style) {
-        widget.charFrame->setStylePreview(m_thumbnailer->thumbnail(m_styleManager->characterStyle(id), widget.charFrame->contentsRect().size()));
+        bool unchanged = true;
+        QTextCharFormat comparisonFormat;
+        style->applyStyle(comparisonFormat);
+        //Here we are making quite a few assumptions:
+        //i. we can set the "ensured" properties on a blank charFormat. These corresponds to Qt default. We are not creating false positive (ie. different styles showing as identical).
+        //ii. a property whose toBool returns as false is identical to an unset property (this is done through the clearUnsetProperties method)
+        style->ensureMinimalProperties(comparisonFormat);
+        style->ensureMinimalProperties(m_currentCharFormat);
+        clearUnsetProperties(comparisonFormat);
+        clearUnsetProperties(m_currentCharFormat);
+        if (m_currentCharFormat.properties().count() != comparisonFormat.properties().count()) {
+            unchanged = false;
+        }
+        else {
+            foreach(int property, m_currentCharFormat.properties().keys()) {
+                if (m_currentCharFormat.property(property) != comparisonFormat.property(property)) {
+                    unchanged = false;
+                }
+            }
+        }
+        disconnect(widget.characterStyleCombo, SIGNAL(selectionChanged(int)), this, SLOT(styleSelected(int)));
+        widget.characterStyleCombo->setCurrentIndex((useParagraphStyle)?0:m_stylesModel->indexForCharacterStyle(*style).row());
+        widget.characterStyleCombo->setStyleIsOriginal(unchanged);
+        widget.characterStyleCombo->slotUpdatePreview();
+        connect(widget.characterStyleCombo, SIGNAL(selectionChanged(int)), this, SLOT(styleSelected(int)));
+    }
+}
+
+void SimpleCharacterWidget::clearUnsetProperties(QTextFormat &format)
+{
+    foreach(int property, format.properties().keys()) {
+        if (!format.property(property).toBool()) {
+            format.clearProperty(property);
+        }
     }
-    m_stylePopup->setCurrentFormat(format);
 }
 
 void SimpleCharacterWidget::fontFamilyActivated(int index) {
@@ -151,4 +189,32 @@ void SimpleCharacterWidget::fontSizeActivated(int index) {
     m_lastFontSizeIndex = index;
 }
 
+void SimpleCharacterWidget::setCurrentBlockFormat(const QTextBlockFormat &format)
+{
+    if (format == m_currentBlockFormat)
+        return;
+    m_currentBlockFormat = format;
+
+    m_stylesModel->setCurrentParagraphStyle(format.intProperty(KoParagraphStyle::StyleId));
+    disconnect(widget.characterStyleCombo, SIGNAL(selectionChanged(int)), this, SLOT(styleSelected(int)));
+    widget.characterStyleCombo->slotUpdatePreview();
+    connect(widget.characterStyleCombo, SIGNAL(selectionChanged(int)), this, SLOT(styleSelected(int)));
+}
+
+void SimpleCharacterWidget::styleSelected(int index)
+{
+    KoCharacterStyle *charStyle = m_styleManager->characterStyle(m_stylesModel->index(index).internalId());
+
+    //if the selected item correspond to a null characterStyle, send the null pointer. the tool should set the characterStyle as per paragraph
+    emit characterStyleSelected(charStyle);
+    emit doneWithFocus();
+}
+
+void SimpleCharacterWidget::slotShowStyleManager(int index)
+{
+    int styleId = m_stylesModel->index(index).internalId();
+    emit showStyleManager(styleId);
+    emit doneWithFocus();
+}
+
 #include <SimpleCharacterWidget.moc>
diff --git a/plugins/textshape/dialogs/SimpleCharacterWidget.h b/plugins/textshape/dialogs/SimpleCharacterWidget.h
index ad944a5..b6d70ec 100644
--- a/plugins/textshape/dialogs/SimpleCharacterWidget.h
+++ b/plugins/textshape/dialogs/SimpleCharacterWidget.h
@@ -1,6 +1,7 @@
 /* This file is part of the KDE project
  * Copyright (C) 2007 Thomas Zander <zander@kde.org>
  * Copyright (C) 2010 Casper Boemann <cbo@boemann.dk>
+ * Copyright (C) 2011-2012 Pierre Stirnweiss <pstirnweiss@googlemail.com>
  *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Library General Public
@@ -29,8 +30,8 @@
 class TextTool;
 class KoStyleManager;
 class KoCharacterStyle;
-class StylesWidget;
 class KoStyleThumbnailer;
+class StylesModel;
 
 class SimpleCharacterWidget : public QWidget
 {
@@ -42,17 +43,23 @@ public:
 public slots:
     void setStyleManager(KoStyleManager *sm);
     void setCurrentFormat(const QTextCharFormat& format);
+    void setCurrentBlockFormat(const QTextBlockFormat &format);
 
 private slots:
     void fontFamilyActivated(int index);
     void fontSizeActivated(int index);
-    void hidePopup();
+    void styleSelected(int index);
+    void slotShowStyleManager(int index);
 
 signals:
     void doneWithFocus();
     void characterStyleSelected(KoCharacterStyle *);
+    void newStyleRequested(QString name);
+    void showStyleManager(int styleId);
 
 private:
+    void clearUnsetProperties(QTextFormat &format);
+
     Ui::SimpleCharacterWidget widget;
     KoStyleManager *m_styleManager;
     bool m_blockSignals;
@@ -61,8 +68,9 @@ private:
     int m_lastFontSizeIndex;
     TextTool *m_tool;
     QTextCharFormat m_currentCharFormat;
+    QTextBlockFormat m_currentBlockFormat;
     KoStyleThumbnailer *m_thumbnailer;
-    StylesWidget *m_stylePopup;
+    StylesModel *m_stylesModel;
 };
 
 #endif
diff --git a/plugins/textshape/dialogs/SimpleCharacterWidget.ui b/plugins/textshape/dialogs/SimpleCharacterWidget.ui
index e4f6d3b..9a049fe 100644
--- a/plugins/textshape/dialogs/SimpleCharacterWidget.ui
+++ b/plugins/textshape/dialogs/SimpleCharacterWidget.ui
@@ -111,25 +111,7 @@
       </spacer>
      </item>
      <item row="0" column="0" colspan="9">
-      <widget class="SpecialButton" name="charFrame">
-       <property name="sizePolicy">
-        <sizepolicy hsizetype="MinimumExpanding" vsizetype="Preferred">
-         <horstretch>0</horstretch>
-         <verstretch>32</verstretch>
-        </sizepolicy>
-       </property>
-       <property name="minimumSize">
-        <size>
-         <width>0</width>
-         <height>20</height>
-        </size>
-       </property>
-       <property name="frameShape">
-        <enum>QFrame::StyledPanel</enum>
-       </property>
-       <property name="frameShadow">
-        <enum>QFrame::Raised</enum>
-       </property>
+      <widget class="StylesCombo" name="characterStyleCombo">
       </widget>
      </item>
     </layout>
@@ -148,9 +130,9 @@
  </widget>
  <customwidgets>
   <customwidget>
-   <class>SpecialButton</class>
-   <extends>QFrame</extends>
-   <header>dialogs/SpecialButton.h</header>
+   <class>StylesCombo</class>
+   <extends>QComboBox</extends>
+   <header>dialogs/StylesCombo.h</header>
    <container>1</container>
   </customwidget>
  </customwidgets>
diff --git a/plugins/textshape/dialogs/SimpleParagraphWidget.cpp b/plugins/textshape/dialogs/SimpleParagraphWidget.cpp
index cbfacfe..df9f630 100644
--- a/plugins/textshape/dialogs/SimpleParagraphWidget.cpp
+++ b/plugins/textshape/dialogs/SimpleParagraphWidget.cpp
@@ -2,6 +2,7 @@
  * Copyright (C) 2007, 2008, 2010 Thomas Zander <zander@kde.org>
  * Copyright (C) 2009-2010 Casper Boemann <cbo@boemann.dk>
  * Copyright (C) 2011 Mojtaba Shahi Senobari <mojtaba.shahi3000@gmail.com>
+ * Copyright (C) 2011-2012 Pierre Stirnweiss <pstirnweiss@googlemail.com>
  *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Library General Public
@@ -22,8 +23,11 @@
 #include "TextTool.h"
 #include <ListItemsHelper.h>
 #include "FormattingButton.h"
-#include "StylesWidget.h"
-#include "SpecialButton.h"
+#include <KoStyleThumbnailer.h>
+
+#include "StylesCombo.h"
+#include "StylesModel.h"
+#include "StylesDelegate.h"
 
 #include <KAction>
 #include <KoTextBlockData.h>
@@ -31,19 +35,22 @@
 #include <KoInlineTextObjectManager.h>
 #include <KoTextDocumentLayout.h>
 #include <KoZoomHandler.h>
-#include <KoStyleThumbnailer.h>
 #include <KoStyleManager.h>
 #include <KoListLevelProperties.h>
 #include <KoShapePaintingContext.h>
 #include <KDebug>
 
 #include <QTextLayout>
+#include <QFlags>
 
 SimpleParagraphWidget::SimpleParagraphWidget(TextTool *tool, QWidget *parent)
         : QWidget(parent),
-        m_blockSignals(false),
-        m_tool(tool),
-        m_directionButtonState(Auto)
+          m_blockSignals(false),
+          m_tool(tool),
+          m_directionButtonState(Auto),
+          m_styleManager(0),
+          m_thumbnailer(new KoStyleThumbnailer()),
+          m_stylesModel(new StylesModel(0, StylesModel::ParagraphStyle))
 {
     widget.setupUi(this);
     widget.alignCenter->setDefaultAction(tool->action("format_aligncenter"));
@@ -80,20 +87,17 @@ SimpleParagraphWidget::SimpleParagraphWidget(TextTool *tool, QWidget *parent)
     connect(widget.bulletListButton, SIGNAL(itemTriggered(int)), this, SLOT(listStyleChanged(int)));
     connect(widget.numberedListButton, SIGNAL(itemTriggered(int)), this, SLOT(listStyleChanged(int)));
 
-    m_stylePopup = new StylesWidget(this, true, Qt::Popup);
-    m_stylePopup->setFrameShape(QFrame::StyledPanel);
-    m_stylePopup->setFrameShadow(QFrame::Raised);
-    widget.blockFrame->setStylesWidget(m_stylePopup);
-
-    connect(m_stylePopup, SIGNAL(paragraphStyleSelected(KoParagraphStyle *)), this, SIGNAL(paragraphStyleSelected(KoParagraphStyle *)));
-    connect(m_stylePopup, SIGNAL(paragraphStyleSelected(KoParagraphStyle *)), this, SIGNAL(doneWithFocus()));
-    connect(m_stylePopup, SIGNAL(paragraphStyleSelected(KoParagraphStyle *)), this, SLOT(hidePopup()));
-
-    m_thumbnailer = new KoStyleThumbnailer();
+    m_stylesModel->setStyleThumbnailer(m_thumbnailer);
+    widget.paragraphStyleCombo->setStylesModel(m_stylesModel);
+    connect(widget.paragraphStyleCombo, SIGNAL(selectionChanged(int)), this, SLOT(styleSelected(int)));
+    connect(widget.paragraphStyleCombo, SIGNAL(newStyleRequested(QString)), this, SIGNAL(newStyleRequested(QString)));
+    connect(widget.paragraphStyleCombo, SIGNAL(newStyleRequested(QString)), this, SIGNAL(doneWithFocus()));
+    connect(widget.paragraphStyleCombo, SIGNAL(showStyleManager(int)), this, SLOT(slotShowStyleManager(int)));
 }
 
 SimpleParagraphWidget::~SimpleParagraphWidget()
 {
+    //the style model is set on the comboBox who takes over ownership
     delete m_thumbnailer;
 }
 
@@ -152,6 +156,10 @@ void SimpleParagraphWidget::fillListButtons()
 
 void SimpleParagraphWidget::setCurrentBlock(const QTextBlock &block)
 {
+    if (block == m_currentBlock) {
+        return;
+    }
+
     m_currentBlock = block;
     m_blockSignals = true;
     struct Finally {
@@ -180,47 +188,86 @@ void SimpleParagraphWidget::setCurrentBlock(const QTextBlock &block)
             }
     }
 
-
-    QTextBlockFormat format;
-
-    int id = format.intProperty(KoParagraphStyle::StyleId);
-    KoParagraphStyle *style(m_styleManager->paragraphStyle(id));
-    if (style) {
-        widget.blockFrame->setStylePreview(m_thumbnailer->thumbnail(style, widget.blockFrame->size()));
-    }
-    m_stylePopup->setCurrentFormat(format);
+    setCurrentFormat(m_currentBlock.blockFormat());
 }
 
 void SimpleParagraphWidget::setCurrentFormat(const QTextBlockFormat &format)
 {
-    if (format == m_currentBlockFormat)
+    if (!m_styleManager || format == m_currentBlockFormat)
         return;
     m_currentBlockFormat = format;
 
     int id = m_currentBlockFormat.intProperty(KoParagraphStyle::StyleId);
     KoParagraphStyle *style(m_styleManager->paragraphStyle(id));
     if (style) {
-        widget.blockFrame->setStylePreview(m_thumbnailer->thumbnail(m_styleManager->paragraphStyle(id), widget.blockFrame->contentsRect().size()));
+        bool unchanged = true;
+        foreach(int property, m_currentBlockFormat.properties().keys()) {
+            if (property == QTextFormat::ObjectIndex)
+                continue;
+            if (property == KoParagraphStyle::ListStyleId)
+                continue;
+            if (property == QTextBlockFormat::BlockAlignment) { //the default alignment can be retrieved in the defaultTextOption. However, calligra sets the Qt::AlignAbsolute flag, so we need to or this flag with the default alignment before comparing.
+                if ((m_currentBlockFormat.property(property) != style->value(property))
+                        && !(style->value(property).isNull()
+                             && ((m_currentBlockFormat.intProperty(property)) == int(m_currentBlock.document()->defaultTextOption().alignment()| Qt::AlignAbsolute)))) {
+                    unchanged = false;
+                    break;
+                }
+                else {
+                    continue;
+                }
+            }
+            if (property == KoParagraphStyle::TextProgressionDirection) {
+                if (style->value(property).isNull() && m_currentBlockFormat.intProperty(property) == KoText::LeftRightTopBottom) {
+                    //LTR seems to be Qt default when unset
+                    continue;
+                }
+            }
+            if ((m_currentBlockFormat.property(property) != style->value(property)) && !(style->value(property).isNull() && !m_currentBlockFormat.property(property).toBool())) {
+                //the last check seems to work. might be cause of a bug. The problem is when comparing an unset property in the style with a set to {0, false, ...) property in the format (eg. set then unset bold)
+                unchanged = false;
+                break;
+            }
+        }
+        //we are updating the combo's selected item to what is the current format. we do not want this to apply the style as it would mess up the undo stack, the change tracking,...
+        disconnect(widget.paragraphStyleCombo, SIGNAL(selectionChanged(int)), this, SLOT(styleSelected(int)));
+        widget.paragraphStyleCombo->setCurrentIndex(m_stylesModel->indexForParagraphStyle(*style).row());
+        widget.paragraphStyleCombo->setStyleIsOriginal(unchanged);
+        m_stylesModel->setCurrentParagraphStyle(id);
+        connect(widget.paragraphStyleCombo, SIGNAL(selectionChanged(int)), this, SLOT(styleSelected(int)));
     }
-    m_stylePopup->setCurrentFormat(format);
 }
 
 void SimpleParagraphWidget::setStyleManager(KoStyleManager *sm)
 {
     m_styleManager = sm;
-    m_stylePopup->setStyleManager(sm);
+    //we want to disconnect this before setting the stylemanager. Populating the model apparently selects the first inserted item. We don't want this to actually set a new style.
+    disconnect(widget.paragraphStyleCombo, SIGNAL(selectionChanged(int)), this, SLOT(styleSelected(int)));
+    m_stylesModel->setStyleManager(sm);
+    connect(widget.paragraphStyleCombo, SIGNAL(selectionChanged(int)), this, SLOT(styleSelected(int)));
 }
 
-void SimpleParagraphWidget::hidePopup()
+void SimpleParagraphWidget::listStyleChanged(int id)
 {
-    widget.blockFrame->hidePopup();
+    emit doneWithFocus();
+    if (m_blockSignals) return;
+    m_tool->textEditor()->setListProperties(static_cast<KoListStyle::Style>(id));
 }
 
-void SimpleParagraphWidget::listStyleChanged(int id)
+void SimpleParagraphWidget::styleSelected(int index)
 {
+    KoParagraphStyle *paragStyle = m_styleManager->paragraphStyle(m_stylesModel->index(index).internalId());
+    if (paragStyle) {
+        emit paragraphStyleSelected(paragStyle);
+    }
+    emit doneWithFocus();
+}
+
+void SimpleParagraphWidget::slotShowStyleManager(int index)
+{
+    int styleId = m_stylesModel->index(index).internalId();
+    emit showStyleManager(styleId);
     emit doneWithFocus();
-    if (m_blockSignals) return;
-    m_tool->textEditor()->setListProperties(static_cast<KoListStyle::Style> (id));
 }
 
 #include <SimpleParagraphWidget.moc>
diff --git a/plugins/textshape/dialogs/SimpleParagraphWidget.h b/plugins/textshape/dialogs/SimpleParagraphWidget.h
index bc167b4..e07be88 100644
--- a/plugins/textshape/dialogs/SimpleParagraphWidget.h
+++ b/plugins/textshape/dialogs/SimpleParagraphWidget.h
@@ -2,6 +2,7 @@
  * Copyright (C) 2007 Thomas Zander <zander@kde.org>
  * Copyright (C) 2010 Casper Boemann <cbo@boemann.dk>
  * Copyright (C) 2011 Mojtaba Shahi Senobari <mojtaba.shahi3000@gmail.com>
+ * Copyright (C) 2011-2012 Pierre Stirnweiss <pstirnweiss@googlemail.com>
  *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Library General Public
@@ -29,9 +30,11 @@
 class TextTool;
 class KoStyleManager;
 class KoParagraphStyle;
-class StylesWidget;
 class KoStyleThumbnailer;
 
+class StylesModel;
+class StylesDelegate;
+
 class SimpleParagraphWidget : public QWidget
 {
     Q_OBJECT
@@ -43,14 +46,17 @@ public slots:
     void setCurrentBlock(const QTextBlock &block);
     void setCurrentFormat(const QTextBlockFormat& format);
     void setStyleManager(KoStyleManager *sm);
-    void hidePopup();
+    void slotShowStyleManager(int index);
 
 signals:
     void doneWithFocus();
     void paragraphStyleSelected(KoParagraphStyle *);
+    void newStyleRequested(QString name);
+    void showStyleManager(int styleId);
 
 private slots:
     void listStyleChanged(int id);
+    void styleSelected(int index);
 
 private:
     enum DirectionButtonState {
@@ -72,7 +78,9 @@ private:
     TextTool *m_tool;
     DirectionButtonState m_directionButtonState;
     KoStyleThumbnailer *m_thumbnailer;
-    StylesWidget *m_stylePopup;
+
+    StylesModel *m_stylesModel;
+    StylesDelegate *m_stylesDelegate;
 };
 
 #endif
diff --git a/plugins/textshape/dialogs/SimpleParagraphWidget.ui b/plugins/textshape/dialogs/SimpleParagraphWidget.ui
index b2e9adf..572055f 100644
--- a/plugins/textshape/dialogs/SimpleParagraphWidget.ui
+++ b/plugins/textshape/dialogs/SimpleParagraphWidget.ui
@@ -118,25 +118,7 @@
       </spacer>
      </item>
      <item row="1" column="0" colspan="11">
-      <widget class="SpecialButton" name="blockFrame">
-       <property name="sizePolicy">
-        <sizepolicy hsizetype="MinimumExpanding" vsizetype="Preferred">
-         <horstretch>0</horstretch>
-         <verstretch>32</verstretch>
-        </sizepolicy>
-       </property>
-       <property name="minimumSize">
-        <size>
-         <width>0</width>
-         <height>0</height>
-        </size>
-       </property>
-       <property name="frameShape">
-        <enum>QFrame::StyledPanel</enum>
-       </property>
-       <property name="frameShadow">
-        <enum>QFrame::Raised</enum>
-       </property>
+      <widget class="StylesCombo" name="paragraphStyleCombo">
       </widget>
      </item>
      <item row="2" column="10">
@@ -163,9 +145,9 @@
    <header>dialogs/FormattingButton.h</header>
   </customwidget>
   <customwidget>
-   <class>SpecialButton</class>
-   <extends>QFrame</extends>
-   <header>dialogs/SpecialButton.h</header>
+   <class>StylesCombo</class>
+   <extends>QComboBox</extends>
+   <header>dialogs/StylesCombo.h</header>
    <container>1</container>
   </customwidget>
  </customwidgets>
diff --git a/plugins/textshape/dialogs/StylesCombo.cpp b/plugins/textshape/dialogs/StylesCombo.cpp
new file mode 100644
index 0000000..5147fb5
--- /dev/null
+++ b/plugins/textshape/dialogs/StylesCombo.cpp
@@ -0,0 +1,188 @@
+/* This file is part of the KDE project
+ * Copyright (C) 2011-2012 Pierre Stirnweiss <pstirnweiss@googlemail.com>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public License
+ * along with this library; see the file COPYING.LIB.  If not, write to
+ * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301, USA.
+*/
+#include "StylesCombo.h"
+#include <KoStyleThumbnailer.h>
+
+#include "StylesModel.h"
+#include "StylesComboPreview.h"
+#include "StylesDelegate.h"
+
+#include <QApplication>
+#include <QListView>
+#include <QSizePolicy>
+#include <QWidget>
+#include <QMouseEvent>
+#include <QPoint>
+#include <QStyleOptionComboBox>
+#include <QStyleOptionViewItemV4>
+#include <QStylePainter>
+
+#include <KDebug>
+
+StylesCombo::StylesCombo(QWidget *parent)
+    : QComboBox(parent),
+      m_stylesModel(0),
+      m_view(new QListView()),
+      m_selectedItem(-1),
+      m_originalStyle(true)
+{
+    setMinimumSize(50,32);
+
+    m_view->setMinimumWidth(250);
+    m_view->setMouseTracking(true);
+    setView(m_view);
+    view()->viewport()->installEventFilter(this);
+
+    StylesDelegate *delegate = new StylesDelegate();
+    connect(delegate, SIGNAL(needsUpdate(QModelIndex)), m_view, SLOT(update(QModelIndex)));
+    connect(delegate, SIGNAL(styleManagerButtonClicked(QModelIndex)), this, SLOT(slotShowDia(QModelIndex)));
+    connect(delegate, SIGNAL(deleteStyleButtonClicked(QModelIndex)), this, SLOT(slotDeleteStyle(QModelIndex)));
+    connect(delegate, SIGNAL(clickedInItem(QModelIndex)), this, SLOT(slotItemClicked(QModelIndex)));
+    setItemDelegate(delegate);
+
+    connect(this, SIGNAL(currentIndexChanged(int)), this, SLOT(slotSelectionChanged(int)));
+
+    QComboBox::setEditable(true);
+    setIconSize(QSize(0,0));
+
+    StylesComboPreview *preview = new StylesComboPreview(this);
+    connect(preview, SIGNAL(newStyleRequested(QString)), this, SIGNAL(newStyleRequested(QString)));
+    QComboBox::setEditable(true);
+    setLineEdit(preview);
+}
+
+StylesCombo::~StylesCombo()
+{
+}
+
+void StylesCombo::setStyleIsOriginal(bool original)
+{
+    m_originalStyle = original;
+    if (!original) {
+        m_preview->setAddButtonShown(true);
+    }
+    else {
+        m_preview->setAddButtonShown(false);
+    }
+}
+
+void StylesCombo::setStylesModel(StylesModel *model)
+{
+    m_stylesModel = model;
+    setModel(model);
+}
+
+void StylesCombo::setEditable(bool editable)
+{
+    if (editable) {
+        // Create a StylesComboPreview instead of a QLineEdit
+        // Compared to QComboBox::setEditable, we might be missing the SH_ComboBox_Popup code though...
+        // If a style needs this, then we'll need to call QComboBox::setEditable and then setLineEdit again
+        StylesComboPreview *edit = new StylesComboPreview( this );
+        setLineEdit( edit );
+    } else {
+        QComboBox::setEditable(editable);
+    }
+}
+
+void StylesCombo::setLineEdit(QLineEdit *edit)
+{
+    if ( !isEditable() && edit &&
+         !qstrcmp( edit->metaObject()->className(), "QLineEdit" ) )
+    {
+        // uic generates code that creates a read-only StylesCombo and then
+        // calls combo->setEditable( true ), which causes QComboBox to set up
+        // a dumb QLineEdit instead of our nice StylesComboPreview.
+        // As some StylesCombo features rely on the StylesComboPreview, we reject
+        // this order here.
+        delete edit;
+        StylesComboPreview* preview = new StylesComboPreview( this );
+        edit = preview;
+    }
+
+    QComboBox::setLineEdit( edit );
+    m_preview = qobject_cast<StylesComboPreview*>( edit );
+
+    if ( m_preview )
+    {
+        connect(m_preview, SIGNAL(resized()), this, SLOT(slotUpdatePreview()));
+    }
+
+}
+
+void StylesCombo::slotSelectionChanged(int index)
+{
+    if (index != m_selectedItem || !m_originalStyle) {
+        m_selectedItem = index;
+        m_preview->setPreview(m_stylesModel->stylePreview(index, m_preview->availableSize()));
+        update();
+        emit selectionChanged(index);
+    }
+}
+
+void StylesCombo::slotItemClicked(QModelIndex index)
+{
+    //this slot allows us to emit a selectionChanged signal in case the already selected style isn't in its original form anymore. In such case, the view does not emit currentIndexChanged, so we use the editorEvent of the delegate to send us a signal. There is a bit of redundancy if the item clicked was indeed a new selection, hence the check in both slots.
+    if (index.row() != m_selectedItem || !m_originalStyle) {
+        m_selectedItem = index.row();
+        m_preview->setPreview(m_stylesModel->stylePreview(m_selectedItem, m_preview->availableSize()));
+        update();
+        emit selectionChanged(m_selectedItem);
+    }
+}
+
+void StylesCombo::slotUpdatePreview()
+{
+    m_preview->setPreview(m_stylesModel->stylePreview(currentIndex(), m_preview->availableSize()));
+    update();
+}
+
+bool StylesCombo::eventFilter(QObject *object, QEvent *event)
+{
+    if (event->type() == QEvent::MouseButtonRelease && object == view()->viewport()) {
+        QMouseEvent *mouseEvent = static_cast<QMouseEvent*>(event);
+        //If what follows isn't a HACK then I have no clue what is!!!!
+        //The item delegate editorEvent method is not sent MouseButtonRelease events.
+        //This is because the QComboBox installs an event filter on the view and calls
+        //popup->hide() on MouseButtonRelease to dismiss the view. Since we installed an event filter on the view
+        //ourselves, we can prevent hiding the popup. We have to call itemDelegate->editorEvent
+        //manually though.
+        QModelIndex index = view()->indexAt(mouseEvent->pos());
+        QModelIndex buddy = m_stylesModel->buddy(index);
+        QStyleOptionViewItemV4 options;
+        options.rect = view()->visualRect(buddy);
+        options.widget = m_view;
+        options.state |= (buddy == view()->currentIndex() ? QStyle::State_HasFocus : QStyle::State_None);
+        return view()->itemDelegate()->editorEvent(mouseEvent, m_stylesModel, options, index);
+    }
+    return false;
+}
+
+void StylesCombo::slotShowDia(QModelIndex index)
+{
+    emit showStyleManager(index.row());
+}
+
+void StylesCombo::slotDeleteStyle(QModelIndex index)
+{
+    emit deleteStyle(index.row());
+}
+
+#include <StylesCombo.moc>
+
diff --git a/plugins/textshape/dialogs/StylesCombo.h b/plugins/textshape/dialogs/StylesCombo.h
new file mode 100644
index 0000000..2bd4dfb
--- /dev/null
+++ b/plugins/textshape/dialogs/StylesCombo.h
@@ -0,0 +1,93 @@
+/* This file is part of the KDE project
+ * Copyright (C) 2011-2012 Pierre Stirnweiss <pstirnweiss@googlemail.com>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public License
+ * along with this library; see the file COPYING.LIB.  If not, write to
+ * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301, USA.
+ */
+#ifndef STYLESCOMBO_H
+#define STYLESCOMBO_H
+
+#include <QComboBox>
+
+class QListView;
+
+class StylesModel;
+class StylesComboPreview;
+
+/** This combo is specifically designed to allow chosing a text style, be it a character style or a paragraph style.
+  * The combo itself does not know what type of style it is dealing with. In that respect it follows pretty much the normal QComboBox paradigm.
+  * This is achieved by setting a @class StylesModel to the combo.
+  * The combo also creates and uses a @class StylesDelegate in order to paint the items as preview in the dropdown menu. This delegate also provide a button to call the style manager dialog directly.
+  * Additionally the combo display the style as a preview in its main area.
+  * The combo allows its user to specify if the current selected style should be considered as original or not. If the style has been modified, a + button appears in the main area. Pressing it will allow to change the name of the style. Focusing out, or pressing enter will send a signal for creating a new style. Escaping will prevent this signal to be sent and return to the preview.
+*/
+
+class StylesCombo : public QComboBox
+{
+    Q_OBJECT
+public:
+    StylesCombo(QWidget *parent);
+    ~StylesCombo();
+
+    /** Use this method to set the @param model of the combo. */
+    void setStylesModel(StylesModel *model);
+
+    /** This method is an override of QComboBox setLineEdit. We need to make it public since its Qt counterpart is public. However, this method is not supposed to be used (unless you know what you are doing). The StylesCombo relies on its own internal QLineEdit subclass for quite a lot of its functionnality. There is no guarantee that the whole thing will work in case the line edit is replaced */
+    void setLineEdit(QLineEdit *lineEdit);
+    /** Same as above */
+    void setEditable(bool editable);
+
+    /** This method is used to specify if the currently selected style is in its original state or is considered modified. In the later case, the + button will appear (see the class description) */
+    void setStyleIsOriginal(bool original);
+
+    bool eventFilter(QObject *, QEvent *);
+
+public slots:
+    /** This slot needs to be called if the preview in the main area needs to be updated for some reason */
+    void slotUpdatePreview();
+
+signals:
+    /** As a normal QComboBox, this is emitted when the selection is changed (programatically or by user interaction). It is to be noted that this signal is also emitted in case a style which is considered modified is selected again.
+      * @param index: the index of the selected item. */
+    void selectionChanged(int index);
+
+    /** This signal is emitted on validation of the name of a modified style (after pressing the + button). This validation happens on focus out or pressed enter key.
+      * @param name: the name by which the new style should be called */
+    void newStyleRequested(QString name);
+
+    /** This signal is emitted when the "show style manager" button is pressed in the dropdown list.
+      * @param index: the index of the item on which the button was pressed */
+    void showStyleManager(int index);
+
+    /** This signal is emitted when the "delete style" button is pressed in the dropdown list.
+      * @param index: the index of the item on which the button was pressed
+      * This is currently disabled */
+    void deleteStyle(int index);
+
+private slots:
+    void slotDeleteStyle(QModelIndex);
+    void slotShowDia(QModelIndex);
+    void slotSelectionChanged(int index);
+    void slotItemClicked(QModelIndex);
+
+private:
+    StylesModel *m_stylesModel;
+    StylesComboPreview *m_preview;
+    QListView *m_view;
+    int m_selectedItem;
+    bool m_originalStyle;
+};
+
+#endif //STYLESCOMBO_H
diff --git a/plugins/textshape/dialogs/StylesComboPreview.cpp b/plugins/textshape/dialogs/StylesComboPreview.cpp
new file mode 100644
index 0000000..c07dff8
--- /dev/null
+++ b/plugins/textshape/dialogs/StylesComboPreview.cpp
@@ -0,0 +1,190 @@
+/* This file is part of the KDE project
+ * Copyright (C) 2011 Pierre Stirnweiss <pstirnweiss@googlemail.com>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public License
+ * along with this library; see the file COPYING.LIB.  If not, write to
+ * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301, USA.
+*/
+
+/*
+ * This class is heavily inspired by KLineEdit, so here goes credit because credit is due (from klineedit.h):
+ *  This class was originally inspired by Torben Weis'
+ *  fileentry.cpp for KFM II.
+
+ *  Sven Radej <sven.radej@iname.com>
+ *  Patrick Ward <PAT_WARD@HP-USA-om5.om.hp.com>
+ *  Preston Brown <pbrown@kde.org>
+
+ *  Completely re-designed:
+ *  Dawit Alemayehu <adawit@kde.org>
+
+*/
+
+#include "StylesComboPreview.h"
+
+#include <QImage>
+#include <QLineEdit>
+#include <QModelIndex>
+#include <QPainter>
+#include <QPaintEvent>
+#include <QFocusEvent>
+#include <QMouseEvent>
+#include <QKeyEvent>
+#include <QPushButton>
+#include <QString>
+
+#include <KIcon>
+#include <KLocale>
+
+#include <KDebug>
+
+StylesComboPreview::StylesComboPreview(QWidget *parent) :
+    QLineEdit(parent),
+    m_renamingNewStyle(false),
+    m_shouldAddNewStyle(false),
+    m_addButton(0)
+{
+    init();
+}
+
+StylesComboPreview::~StylesComboPreview()
+{
+    delete m_addButton;
+    m_addButton = 0;
+}
+
+void StylesComboPreview::init()
+{
+    setReadOnly(true);
+    if (m_addButton) {
+        return;
+    }
+
+    m_addButton = new QPushButton(this);
+    m_addButton->setCursor( Qt::ArrowCursor );
+    m_addButton->setIcon(KIcon("list-add"));
+    m_addButton->setFlat(true);
+    m_addButton->setMinimumSize(16,16);
+    m_addButton->setMaximumSize(16, 16);
+//TODO uncomment the following line after string freeze
+//    m_addButton->setToolTip( i18nc( "@action:button Create a new style with the current properties", "Create style" ) );
+    connect(m_addButton, SIGNAL(clicked()), this, SLOT(addNewStyle()));
+
+    updateAddButton();
+}
+
+void StylesComboPreview::updateAddButton()
+{
+    if (!m_addButton) {
+        return;
+    }
+
+    const QSize geom = size();
+    const int buttonWidth = m_addButton->size().width();
+    m_addButton->move(geom.width() - buttonWidth , (geom.height()-m_addButton->size().height())/2);
+}
+
+void StylesComboPreview::setAddButtonShown(bool show)
+{
+    m_addButton->setVisible(show);
+}
+
+QSize StylesComboPreview::availableSize() const
+{
+    return QSize(contentsRect().width()- m_addButton->width(), contentsRect().height()); ///TODO dynamic resizing when button shown/hidden.
+}
+
+void StylesComboPreview::setPreview(QImage image)
+{
+    m_stylePreview = image;
+}
+
+bool StylesComboPreview::isAddButtonShown() const
+{
+    return m_addButton != 0;
+}
+
+void StylesComboPreview::resizeEvent( QResizeEvent * ev )
+{
+    QLineEdit::resizeEvent(ev);
+    emit resized();
+    updateAddButton();
+}
+
+void StylesComboPreview::keyPressEvent( QKeyEvent *e )
+{
+    if (m_shouldAddNewStyle && e->key() == Qt::Key_Escape) {
+        m_renamingNewStyle = false;
+        m_shouldAddNewStyle = false;
+        setReadOnly(true);
+        setText(QString());
+        e->accept();
+    }
+    else if (m_shouldAddNewStyle && (e->key() == Qt::Key_Enter || e->key() == Qt::Key_Return)) {
+        m_renamingNewStyle = false;
+        m_shouldAddNewStyle = false;
+        emit newStyleRequested(text());
+        setReadOnly(true);
+        setText(QString());
+        e->accept();
+    }
+    else {
+        QLineEdit::keyPressEvent(e);
+    }
+}
+
+void StylesComboPreview::focusOutEvent(QFocusEvent *e)
+{
+    if (e->reason() != Qt::ActiveWindowFocusReason && e->reason() != Qt::PopupFocusReason) {
+        if (m_shouldAddNewStyle) {
+            m_renamingNewStyle = false;
+            m_shouldAddNewStyle = false;
+            emit newStyleRequested(text());
+            setReadOnly(true);
+            setText(QString());
+            e->accept();
+        }
+        setReadOnly(true);
+        m_renamingNewStyle = false;
+        setText(QString());
+    }
+    else {
+        QLineEdit::focusOutEvent(e);
+    }
+}
+
+void StylesComboPreview::paintEvent( QPaintEvent *ev )
+{
+    if (!m_renamingNewStyle) {
+        QLineEdit::paintEvent(ev);
+        QPainter p(this);
+        p.setClipRect(ev->rect());
+        p.drawImage(contentsRect().topLeft(), m_stylePreview);
+    }
+    else {
+        QLineEdit::paintEvent(ev);
+    }
+}
+
+void StylesComboPreview::addNewStyle()
+{
+    m_renamingNewStyle = true;
+    m_shouldAddNewStyle = true;
+    setText(i18n("New style"));
+    selectAll();
+    setReadOnly(false);
+    this->setFocus();
+}
+
+#include "StylesComboPreview.moc"
diff --git a/plugins/textshape/dialogs/StylesComboPreview.h b/plugins/textshape/dialogs/StylesComboPreview.h
new file mode 100644
index 0000000..e98ebf4
--- /dev/null
+++ b/plugins/textshape/dialogs/StylesComboPreview.h
@@ -0,0 +1,74 @@
+/* This file is part of the KDE project
+ * Copyright (C) 2011 Pierre Stirnweiss <pstirnweiss@googlemail.com>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public License
+ * along with this library; see the file COPYING.LIB.  If not, write to
+ * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301, USA.
+*/
+
+#ifndef STYLESCOMBOPREVIEW_H
+#define STYLESCOMBOPREVIEW_H
+
+#include <QLineEdit>
+
+class QModelIndex;
+class QImage;
+class QPushButton;
+class QSize;
+class QString;
+
+/** This is an internal class, used for the preview of styles in the main area of the @class StylesCombo. */
+
+class StylesComboPreview : public QLineEdit
+{
+    Q_OBJECT
+
+    Q_PROPERTY( bool showAddButton READ isAddButtonShown WRITE setAddButtonShown )
+
+public:
+    explicit StylesComboPreview(QWidget *parent = 0);
+    ~StylesComboPreview();
+
+    QSize availableSize() const;
+    void setAddButtonShown(bool show);
+    bool isAddButtonShown() const;
+
+    void setPreview(QImage image);
+
+signals:
+    void resized();
+    void newStyleRequested(QString name);
+
+protected:
+    virtual void resizeEvent(QResizeEvent *event);
+    virtual void keyPressEvent(QKeyEvent *event);
+    virtual void focusOutEvent(QFocusEvent *);
+    virtual void paintEvent(QPaintEvent *event);
+
+private slots:
+    void addNewStyle();
+
+private:
+    void init();
+    void updateAddButton();
+
+    bool m_renamingNewStyle;
+    bool m_shouldAddNewStyle;
+
+    QImage m_stylePreview;
+
+    QPushButton *m_addButton;
+};
+
+#endif // STYLESCOMBOPREVIEW_H
diff --git a/plugins/textshape/dialogs/StylesDelegate.cpp b/plugins/textshape/dialogs/StylesDelegate.cpp
index d1021f5..3a2dee3 100644
--- a/plugins/textshape/dialogs/StylesDelegate.cpp
+++ b/plugins/textshape/dialogs/StylesDelegate.cpp
@@ -1,5 +1,6 @@
 /* This file is part of the KDE project
  * Copyright (C) 2011 Casper Boemann <cbo@boemann.dk>
+ * Copyright (C) 2011-2012 Pierre Stirnweiss <pstirnweiss@googlemail.com>
  *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Library General Public
@@ -19,25 +20,188 @@
 
 #include "StylesDelegate.h"
 
+
+#include <QAbstractItemView>
+#include <QColor>
+#include <QEvent>
+#include <QMouseEvent>
 #include <QPainter>
+#include <QPen>
+#include <QRect>
+#include <QScrollBar>
+#include <QStyle>
+#include <QStyleOptionButton>
+#include <QStyleOptionViewItemV4>
+
+#include <KIcon>
+#include <KDebug>
+
 
 StylesDelegate::StylesDelegate()
- : QStyledItemDelegate()
+    : QStyledItemDelegate(),
+      m_editButtonPressed(false),
+      m_deleteButtonPressed(false)
 {
+    m_buttonSize = 16;
+    m_buttonDistance = 2;
 }
 
-void StylesDelegate::paint(QPainter *painter, const QStyleOptionViewItem &option,
+void StylesDelegate::paint(QPainter *painter, const QStyleOptionViewItem &optionV1,
                             const QModelIndex &index) const
 {
-   if (index.column() == 1) {
-         painter->fillRect(option.rect, QColor(Qt::red));
+    QStyleOptionViewItemV4 option = optionV1;
+    initStyleOption(&option, index);
+    QStyledItemDelegate::paint(painter, option, index);
 
-   } else {
-         QStyledItemDelegate::paint(painter, option, index);
-   }
+    //the following is needed to find out if the view has vertical scrollbars. If there is no view just paint and do not attempt to draw the control buttons.
+    //this is needed because it seems that the option.rect given does not exclude the vertical scrollBar. This means that we can draw the button in an area that is going to be covered by the vertical scrollBar.
+    const QAbstractItemView *view = static_cast<const QAbstractItemView*>(option.widget);
+    if (!view){
+        return;
+    }
+    QScrollBar *scrollBar = view->verticalScrollBar();
+    int scrollBarWidth = 0;
+    if (scrollBar->isVisible()) {
+        scrollBarWidth = scrollBar->width();
+    }
+
+    if (!index.isValid() || !(option.state & QStyle::State_MouseOver)) {
+    return;
+    }
+    // Delete style button.
+    int dx1 = option.rect.width() - qMin(option.rect.height()-2, m_buttonSize) - m_buttonSize - m_buttonDistance -2;
+    int dy1 = 1 + (option.rect.height()-qMin(option.rect.height(), m_buttonSize))/2;
+    int dx2 = -m_buttonSize - m_buttonDistance -2;
+    int dy2 = -1 -(option.rect.height()-qMin(option.rect.height(), m_buttonSize))/2;
+/* TODO: when we can safely delete styles, re-enable this
+    QStyleOptionButton optDel;
+    if (!m_deleteButtonPressed) {
+        optDel.state |= QStyle::State_Enabled;
+    }
+    optDel.icon = KIcon("edit-delete");
+    optDel.features |= QStyleOptionButton::Flat;
+    optDel.rect = option.rect.adjusted(dx1 - scrollBarWidth, dy1, dx2 - scrollBarWidth, dy2);
+    view->style()->drawControl(QStyle::CE_PushButton, &optDel, painter, 0);
+*/
+    // Open style manager dialog button.
+    dx1 = option.rect.width() - qMin(option.rect.height()-2, m_buttonSize) -2;
+    dy1 = 1 + (option.rect.height()-qMin(option.rect.height(), m_buttonSize))/2;
+    dx2 = -2;
+    dy2 = -1 -(option.rect.height()-qMin(option.rect.height(), m_buttonSize))/2;
+    QStyleOptionButton optEdit;
+    if (!m_editButtonPressed) {
+        optEdit.state |= QStyle::State_Enabled;
+    }
+    optEdit.icon = KIcon("document-properties");
+    optEdit.features |= QStyleOptionButton::Flat;
+    optEdit.rect = option.rect.adjusted(dx1 - scrollBarWidth, dy1, dx2 - scrollBarWidth, dy2);
+    view->style()->drawControl(QStyle::CE_PushButton, &optEdit, painter, 0);
 }
 
 QSize StylesDelegate::sizeHint(const QStyleOptionViewItem &option, const QModelIndex &index) const
 {
-    return QSize(250,48);
+    Q_UNUSED(index);
+    Q_UNUSED(option);
+    return QSize(250, 48);
+}
+
+bool StylesDelegate::editorEvent(QEvent *event, QAbstractItemModel *model, const QStyleOptionViewItem &optionV1, const QModelIndex &index)
+{
+    Q_UNUSED(model);
+    QStyleOptionViewItemV4 option = optionV1;
+    initStyleOption(&option, index);
+
+    //the following is needed to find out if the view has vertical scrollbars. If not just paint and do not attempt to draw the control buttons.
+    //this is needed because it seems that the option.rect given does not exclude the vertical scrollBar. This means that we can draw the button in an area that is going to be covered by the vertical scrollBar.
+
+    const QAbstractItemView *view = static_cast<const QAbstractItemView*>(option.widget);
+    if (!view){
+        return false;
+    }
+    QScrollBar *scrollBar = view->verticalScrollBar();
+    int scrollBarWidth = 0;
+    if (scrollBar->isVisible()) {
+        scrollBarWidth = scrollBar->width();
+    }
+
+    if (event->type() == QEvent::MouseButtonPress) {
+        QMouseEvent *mouseEvent = static_cast<QMouseEvent*>(event);
+        int dx1 = option.rect.width()- qMin(option.rect.height()-2, m_buttonSize) - m_buttonSize - m_buttonDistance -2;
+        int dy1 = 1 + (option.rect.height()-qMin(option.rect.height(), m_buttonSize))/2;
+        int dx2 = - m_buttonSize - m_buttonDistance -2;
+        int dy2 = -1 -(option.rect.height()-qMin(option.rect.height(), m_buttonSize))/2;
+/*TODO: when we can safely delete styles, re-enable this
+        QRect delRect = option.rect.adjusted(dx1 - scrollBarWidth, dy1, dx2 - scrollBarWidth, dy2);
+        if (delRect.contains(mouseEvent->pos())) {
+            m_deleteButtonPressed = true;
+        }
+        else {
+            m_deleteButtonPressed = false;
+        }
+*/
+        dx1 = option.rect.width() - qMin(option.rect.height()-2, m_buttonSize) -2;
+        dy1 = 1 + (option.rect.height()-qMin(option.rect.height(), m_buttonSize))/2;
+        dx2 = -2;
+        dy2 = -1 -(option.rect.height()-qMin(option.rect.height(), m_buttonSize))/2;
+        QRect editRect = option.rect.adjusted(dx1 - scrollBarWidth, dy1, dx2 - scrollBarWidth, dy2);
+        if (editRect.contains(mouseEvent->pos())){
+            m_editButtonPressed = true;
+        }
+        else {
+            m_editButtonPressed = false;
+        }
+        emit needsUpdate(index);
+    }
+    if (event->type() == QEvent::MouseButtonRelease) {
+        m_deleteButtonPressed = false;
+        m_editButtonPressed = false;
+        emit needsUpdate(index);
+        QMouseEvent *mouseEvent = static_cast<QMouseEvent*>(event);
+        int dx1 = option.rect.width() - qMin(option.rect.height()-2, m_buttonSize) - m_buttonSize - m_buttonDistance -2;
+        int dy1 = 1 + (option.rect.height()-qMin(option.rect.height(), m_buttonSize))/2;
+        int dx2 = - m_buttonSize - m_buttonDistance -2;
+        int dy2 = -1 -(option.rect.height()-qMin(option.rect.height(), m_buttonSize))/2;
+/*TODO: when we can safely delete styles, re-enable this
+        QRect delRect = option.rect.adjusted(dx1 - scrollBarWidth, dy1, dx2 - scrollBarWidth, dy2);
+        if (delRect.contains(mouseEvent->pos())) {
+            emit deleteStyleButtonClicked(index);
+            return true;
+        }
+*/
+        dx1 = option.rect.width() - qMin(option.rect.height()-2, m_buttonSize) -2;
+        dy1 = 1 + (option.rect.height()-qMin(option.rect.height(), m_buttonSize))/2;
+        dx2 = -2;
+        dy2 = -1 -(option.rect.height()-qMin(option.rect.height(), m_buttonSize))/2;
+        QRect editRect = option.rect.adjusted(dx1 - scrollBarWidth, dy1, dx2 - scrollBarWidth, dy2);
+        if (editRect.contains(mouseEvent->pos())){
+            emit styleManagerButtonClicked(index);
+            return true;
+        }
+        emit clickedInItem(index);
+        return false;
+    }
+    if (event->type() == QEvent::MouseMove) {
+        QMouseEvent *mouseEvent = static_cast<QMouseEvent*>(event);
+        int dx1 = option.rect.width() - qMin(option.rect.height()-2, m_buttonSize) - m_buttonSize - m_buttonDistance -2;
+        int dy1 = 1 + (option.rect.height()-qMin(option.rect.height(), m_buttonSize))/2;
+        int dx2 = - m_buttonSize - m_buttonDistance -2;
+        int dy2 = -1 -(option.rect.height()-qMin(option.rect.height(), m_buttonSize))/2;
+/*TODO: when we can safely delete styles, re-enable this
+        QRect delRect = option.rect.adjusted(dx1 - scrollBarWidth, dy1, dx2 - scrollBarWidth, dy2);
+        if (!delRect.contains(mouseEvent->pos())) {
+            m_deleteButtonPressed = false;
+        }
+*/
+        dx1 = option.rect.width() - qMin(option.rect.height()-2, m_buttonSize) -2;
+        dy1 = 1 + (option.rect.height()-qMin(option.rect.height(), m_buttonSize))/2;
+        dx2 = -2;
+        dy2 = -1 -(option.rect.height()-qMin(option.rect.height(), m_buttonSize))/2;
+        QRect editRect = option.rect.adjusted(dx1 - scrollBarWidth, dy1, dx2 - scrollBarWidth, dy2);
+        if (!editRect.contains(mouseEvent->pos())){
+            m_editButtonPressed = false;
+        }
+        emit needsUpdate(index);
+        return false;
+    }
+    return false;
 }
diff --git a/plugins/textshape/dialogs/StylesDelegate.h b/plugins/textshape/dialogs/StylesDelegate.h
index f5d216f..d7d0572 100644
--- a/plugins/textshape/dialogs/StylesDelegate.h
+++ b/plugins/textshape/dialogs/StylesDelegate.h
@@ -1,5 +1,6 @@
 /* This file is part of the KDE project
  * Copyright (C) 2011 Casper Boemann <cbo@boemann.dk>
+ * Copyright (C) 2011-2012 Pierre Stirnweiss <pstirnweiss@googlemail.com>
  *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Library General Public
@@ -21,19 +22,36 @@
 
 #include <QStyledItemDelegate>
 
-class KoStyleManager;
-class KoParagraphStyle;
-class KoCharacterStyle;
+/** This is an internal class, used for the preview of styles in the dropdown of the @class StylesCombo.
+  * This class is also responsible for drawing and handling the buttons to call the style manager or to delete a style.
+  * NB. Deleting a style is currently not supported, therefore the button has been disabled. */
 
 class StylesDelegate : public QStyledItemDelegate
 {
     Q_OBJECT
+
 public:
     StylesDelegate();
 
     virtual void paint(QPainter *painter, const QStyleOptionViewItem &option,
                             const QModelIndex &index) const;
     virtual QSize sizeHint(const QStyleOptionViewItem &option, const QModelIndex &index) const;
+
+    virtual bool editorEvent(QEvent *event, QAbstractItemModel *model,
+                            const QStyleOptionViewItem &option, const QModelIndex &index);
+
+signals:
+    void styleManagerButtonClicked(QModelIndex index);
+    void deleteStyleButtonClicked(QModelIndex index);
+    void needsUpdate(QModelIndex index);
+    void clickedInItem(QModelIndex index);
+
+private:
+    bool m_editButtonPressed;
+    bool m_deleteButtonPressed;
+
+    int m_buttonSize;
+    int m_buttonDistance;
 };
 
 #endif
diff --git a/plugins/textshape/dialogs/StylesModel.cpp b/plugins/textshape/dialogs/StylesModel.cpp
index 94deb24..5f1d1a4 100644
--- a/plugins/textshape/dialogs/StylesModel.cpp
+++ b/plugins/textshape/dialogs/StylesModel.cpp
@@ -1,6 +1,7 @@
 /* This file is part of the KDE project
  * Copyright (C) 2008 Thomas Zander <zander@kde.org>
  * Copyright (C) 2011 Casper Boemann <cbo@boemann.dk>
+ * Copyright (C) 2011-2012 Pierre Stirnweiss <pstirnweiss@googlemail.org>
  *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Library General Public
@@ -18,44 +19,37 @@
  * Boston, MA 02110-1301, USA.
  */
 #include "StylesModel.h"
-#include "TextTool.h"
 
-#include <QSet>
-#include <QDebug>
-#include <QSignalMapper>
-#include <QTextLayout>
-#include <QTextBlock>
-
-#include <KoStyleManager.h>
 #include <KoStyleThumbnailer.h>
+#include <KoStyleManager.h>
 #include <KoParagraphStyle.h>
 #include <KoCharacterStyle.h>
 
+#include <QSignalMapper>
+#include <QList>
+#include <QImage>
+
 #include <KIcon>
-#include <KoTextBlockData.h>
-#include <KoParagraphStyle.h>
-#include <KoInlineTextObjectManager.h>
-#include <KoTextDocumentLayout.h>
-#include <KoZoomHandler.h>
 
 #include <KDebug>
 
-#include <QTextLayout>
-
-
-StylesModel::StylesModel(KoStyleManager *manager, bool paragraphMode, QObject *parent)
+StylesModel::StylesModel(KoStyleManager *manager, Type modelType, QObject *parent)
     : QAbstractListModel(parent),
       m_styleManager(0),
       m_styleThumbnailer(0),
       m_currentParagraphStyle(0),
-      m_currentCharacterStyle(0),
-      m_pureParagraphStyle(true),
-      m_pureCharacterStyle(true),
-      m_paragraphMode(paragraphMode),
-      m_styleMapper(new QSignalMapper(this)),
-      m_tmpTextShape(0)
-{
+      m_defaultCharacterStyle(0),
+      m_modelType(modelType),
+      m_styleMapper(new QSignalMapper(this)){
     setStyleManager(manager);
+    //Create a default characterStyle for the preview of "As paragraph" character style
+    if (m_modelType == StylesModel::CharacterStyle) {
+        m_defaultCharacterStyle = new KoCharacterStyle();
+        m_defaultCharacterStyle->setStyleId(-1);
+        m_defaultCharacterStyle->setName(QString("As paragraph"));
+        m_defaultCharacterStyle->setFontPointSize(12);
+    }
+
     m_paragIcon = KIcon("kotext-paragraph");
     m_charIcon = KIcon("kotext-character");
     connect(m_styleMapper, SIGNAL(mapped(int)), this, SLOT(updateName(int)));
@@ -63,7 +57,8 @@ StylesModel::StylesModel(KoStyleManager *manager, bool paragraphMode, QObject *p
 
 StylesModel::~StylesModel()
 {
-    delete m_tmpTextShape;
+    delete m_currentParagraphStyle;
+    delete m_defaultCharacterStyle;
 }
 
 QModelIndex StylesModel::index(int row, int column, const QModelIndex &parent) const
@@ -92,29 +87,40 @@ QVariant StylesModel::data(const QModelIndex &index, int role) const
     if (!index.isValid())
         return QVariant();
 
-    int id = (int) index.internalId();
-    switch (role) {
+    int id = (int)index.internalId();
+    switch (role){
     case Qt::DisplayRole: {
         return QVariant();
-        KoParagraphStyle *paragStyle = m_styleManager->paragraphStyle(id);
-        if (paragStyle)
-            return paragStyle->name();
-        KoCharacterStyle *characterStyle =  m_styleManager->characterStyle(id);
-        if (characterStyle)
-            return characterStyle->name();
-        break;
     }
     case Qt::DecorationRole: {
         if (!m_styleThumbnailer) {
             return QPixmap();
         }
-        KoParagraphStyle *paragStyle = m_styleManager->paragraphStyle(id);
-        if (paragStyle) {
-            return m_styleThumbnailer->thumbnail(paragStyle);
+        if (m_modelType == StylesModel::ParagraphStyle) {
+            KoParagraphStyle *paragStyle = m_styleManager->paragraphStyle(id);
+            if (paragStyle) {
+                return m_styleThumbnailer->thumbnail(paragStyle);
+            }
         }
-        KoCharacterStyle *characterStyle =  m_styleManager->characterStyle(id);
-        if (characterStyle) {
-            return m_styleThumbnailer->thumbnail(characterStyle);
+        else {
+            KoCharacterStyle *usedStyle = 0;
+            if (id == -1) {
+                usedStyle = static_cast<KoCharacterStyle*>(m_currentParagraphStyle);
+                if (!usedStyle) {
+                    usedStyle = m_defaultCharacterStyle;
+                }
+                usedStyle->setName(QString("As paragraph"));
+                if (usedStyle->styleId() >= 0) { //if the styleId is -1, we are using the default character style
+                    usedStyle->setStyleId(-usedStyle->styleId()); //this style is not managed by the styleManager but its styleId will be used in the thumbnail cache as part of the key.
+                }
+                return m_styleThumbnailer->thumbnail(usedStyle);
+            }
+            else {
+                usedStyle = m_styleManager->characterStyle(id);
+                if (usedStyle) {
+                    return m_styleThumbnailer->thumbnail(usedStyle);
+                }
+            }
         }
         break;
     }
@@ -130,20 +136,16 @@ Qt::ItemFlags StylesModel::flags(const QModelIndex &index) const
     return (Qt::ItemIsSelectable | Qt::ItemIsEnabled);
 }
 
-void StylesModel::setCurrentParagraphStyle(int styleId, bool unchanged)
+void StylesModel::setCurrentParagraphStyle(int styleId)
 {
-    if (m_currentParagraphStyle == styleId && unchanged == m_pureParagraphStyle)
-        return;
-    m_currentParagraphStyle = styleId;
-    m_pureParagraphStyle = unchanged;
-}
-
-void StylesModel::setCurrentCharacterStyle(int styleId, bool unchanged)
-{
-    if (m_currentCharacterStyle == styleId && unchanged == m_pureCharacterStyle)
-        return;
-    m_currentCharacterStyle = styleId;
-    m_pureCharacterStyle = unchanged;
+    if (!m_styleManager || m_currentParagraphStyle == m_styleManager->paragraphStyle(styleId) || !m_styleManager->paragraphStyle(styleId)) {
+        return; //TODO do we create a default paragraphStyle? use the styleManager default?
+    }
+    if (m_currentParagraphStyle) {
+        delete m_currentParagraphStyle;
+        m_currentParagraphStyle = 0;
+    }
+    m_currentParagraphStyle = m_styleManager->paragraphStyle(styleId)->clone();
 }
 
 KoParagraphStyle *StylesModel::paragraphStyleForIndex(const QModelIndex &index) const
@@ -154,7 +156,8 @@ KoParagraphStyle *StylesModel::paragraphStyleForIndex(const QModelIndex &index)
 QModelIndex StylesModel::indexForParagraphStyle(const KoParagraphStyle &style) const
 {
     if (&style) {
-        return createIndex(m_styleList.indexOf(style.styleId()), 0, style.styleId());;
+        QModelIndex index = createIndex(m_styleList.indexOf(style.styleId()), 0, style.styleId());
+        return index;
     }
     else {
         return QModelIndex();
@@ -176,6 +179,41 @@ QModelIndex StylesModel::indexForCharacterStyle(const KoCharacterStyle &style) c
     }
 }
 
+QImage StylesModel::stylePreview(int row, QSize size)
+{
+    if (!m_styleManager || !m_styleThumbnailer) {
+        return QImage();
+    }
+    if (m_modelType == StylesModel::ParagraphStyle) {
+        KoParagraphStyle *usedStyle = 0;
+        usedStyle = m_styleManager->paragraphStyle(index(row).internalId());
+        if (usedStyle) {
+            return m_styleThumbnailer->thumbnail(usedStyle, size);
+        }
+    }
+    else {
+        KoCharacterStyle *usedStyle = 0;
+        if (index(row).internalId() == -1) {
+            usedStyle = static_cast<KoCharacterStyle*>(m_currentParagraphStyle);
+            if (!usedStyle) {
+                usedStyle = m_defaultCharacterStyle;
+            }
+            usedStyle->setName(QString("As paragraph"));
+            if (usedStyle->styleId() >= 0) {
+                usedStyle->setStyleId(-usedStyle->styleId()); //this style is not managed by the styleManager but its styleId will be used in the thumbnail cache as part of the key.
+            }
+            return m_styleThumbnailer->thumbnail(usedStyle, size);
+        }
+        else {
+            usedStyle = m_styleManager->characterStyle(index(row).internalId());
+            if (usedStyle) {
+                return m_styleThumbnailer->thumbnail(usedStyle, size);
+            }
+        }
+    }
+    return QImage();
+}
+
 void StylesModel::setStyleManager(KoStyleManager *sm)
 {
     if (sm == m_styleManager)
@@ -191,12 +229,15 @@ void StylesModel::setStyleManager(KoStyleManager *sm)
         return;
     }
 
-    if (m_paragraphMode) {
+    if (m_modelType == StylesModel::ParagraphStyle) {
         foreach(KoParagraphStyle *style, m_styleManager->paragraphStyles())
             addParagraphStyle(style);
         connect(sm, SIGNAL(styleAdded(KoParagraphStyle*)), this, SLOT(addParagraphStyle(KoParagraphStyle*)));
         connect(sm, SIGNAL(styleRemoved(KoParagraphStyle*)), this, SLOT(removeParagraphStyle(KoParagraphStyle*)));
     } else {
+        if (m_styleManager->paragraphStyles().count()) {
+            m_styleList.append(-1);
+        }
         foreach(KoCharacterStyle *style, m_styleManager->characterStyles())
             addCharacterStyle(style);
         connect(sm, SIGNAL(styleAdded(KoCharacterStyle*)), this, SLOT(addCharacterStyle(KoCharacterStyle*)));
@@ -213,16 +254,20 @@ void StylesModel::setStyleThumbnailer(KoStyleThumbnailer *thumbnailer)
 void StylesModel::addParagraphStyle(KoParagraphStyle *style)
 {
     Q_ASSERT(style);
+    beginInsertRows(QModelIndex(), rowCount(QModelIndex()), rowCount(QModelIndex()));
     m_styleList.append(style->styleId());
     m_styleMapper->setMapping(style, style->styleId());
     connect(style, SIGNAL(nameChanged(const QString&)), m_styleMapper, SLOT(map()));
+    endInsertRows();
 }
 
 // called when the stylemanager adds a style
 void StylesModel::addCharacterStyle(KoCharacterStyle *style)
 {
     Q_ASSERT(style);
+    beginInsertRows(QModelIndex(), rowCount(QModelIndex()), rowCount(QModelIndex()));
     m_styleList.append(style->styleId());
+    endInsertRows();
     m_styleMapper->setMapping(style, style->styleId());
     connect(style, SIGNAL(nameChanged(const QString&)), m_styleMapper, SLOT(map()));
 }
@@ -230,15 +275,23 @@ void StylesModel::addCharacterStyle(KoCharacterStyle *style)
 // called when the stylemanager removes a style
 void StylesModel::removeParagraphStyle(KoParagraphStyle *style)
 {
+    int row = m_styleList.indexOf(style->styleId());
+    beginRemoveRows(QModelIndex(), row, row);
     m_styleMapper->removeMappings(style);
     disconnect(style, SIGNAL(nameChanged(const QString&)), m_styleMapper, SLOT(map()));
+    m_styleList.removeAt(row);
+    endRemoveRows();
 }
 
 // called when the stylemanager removes a style
 void StylesModel::removeCharacterStyle(KoCharacterStyle *style)
 {
+    int row = m_styleList.indexOf(style->styleId());
+    beginRemoveRows(QModelIndex(), row, row);
     m_styleMapper->removeMappings(style);
     disconnect(style, SIGNAL(nameChanged(const QString&)), m_styleMapper, SLOT(map()));
+    m_styleList.removeAt(row);
+    endRemoveRows();
 }
 
 void StylesModel::updateName(int styleId)
diff --git a/plugins/textshape/dialogs/StylesModel.h b/plugins/textshape/dialogs/StylesModel.h
index dbd17b4..0e9fcba 100644
--- a/plugins/textshape/dialogs/StylesModel.h
+++ b/plugins/textshape/dialogs/StylesModel.h
@@ -1,6 +1,7 @@
 /* This file is part of the KDE project
  * Copyright (C) 2008 Thomas Zander <zander@kde.org>
  * Copyright (C) 2011 Casper Boemann <cbo@boemann.dk>
+ * Copyright (C) 2011-2012 Pierre Stirnweiss <pstirnweiss@googlemail.org>
  *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Library General Public
@@ -21,27 +22,39 @@
 #define MODEL_H
 
 #include <QAbstractListModel>
-#include <QMultiHash>
-#include <QIcon>
-#include <QPixmap>
-#include <QMap>
+#include <KIcon>
 
 class KoStyleThumbnailer;
 
 class KoStyleManager;
 class KoParagraphStyle;
 class KoCharacterStyle;
+
+class QImage;
 class QSignalMapper;
-class TextShape;
+class QSize;
+
+/** This class is used to provide widgets (like the @class StylesCombo) the styles available to the document being worked on. The @class StylesModel can be of two types: character styles or paragraph styles type. This allows the widget to ignore the type of style it is handling.
+  * Character styles in ODF can be specified in two ways. First, a named character style, specifying character formatting properties. It is meant to be used on a couple of individual characters. Secondely, a paragraph style also specifies character formatting properties, which are to be considered the default for that particular paragraph.
+  * For this reason, the @class Stylesmodel, when of the type @value characterStyle, do not list the paragraph style names. Only the specific named chracter styles are listed. Additionnaly, as the first item, a virtual style "As paragraph" is provided. Selecting this "style" will set the character properties as specified by the paragraph style currently applied to the selection.
+  * This class requires that a @class KoStyleManager and a @class KoStyleThumbnailer be set. See below methods.
+*/
 
 class StylesModel : public QAbstractListModel
 {
     Q_OBJECT
 
 public:
-    explicit StylesModel(KoStyleManager *styleManager, bool paragraphMode, QObject *parent = 0);
+    enum Type {
+        CharacterStyle,
+        ParagraphStyle
+    };
+
+    explicit StylesModel(KoStyleManager *styleManager, Type modelType, QObject *parent = 0);
     ~StylesModel();
 
+    /** Re-implemented from QAbstractItemModel. */
+
     virtual QModelIndex index(int row, int column=0, const QModelIndex &parent = QModelIndex()) const;
 
     virtual int rowCount(const QModelIndex &parent) const;
@@ -50,28 +63,32 @@ public:
 
     virtual Qt::ItemFlags flags(const QModelIndex &index) const;
 
+    /** Specific methods of the StylesModel */
+
+    /** Returns the @class KoParagraphStyle corresponding to the specified @param index. */
     KoParagraphStyle *paragraphStyleForIndex(const QModelIndex &index) const;
+    /** Return a @class QModelIndex for the specified @param style. */
     QModelIndex indexForParagraphStyle(const KoParagraphStyle &style) const;
 
+    /** Returns the @class KoCharacterhStyle corresponding to the specified @param index. */
     KoCharacterStyle *characterStyleForIndex(const QModelIndex &index) const;
+    /** Return a @class QModelIndex for the specified @param style. */
     QModelIndex indexForCharacterStyle(const KoCharacterStyle &style) const;
 
+    /** Returns a QImage which is a preview of the style specified by @param row of the given @param size.
+      * If size isn't specified, the default size of the given @class KoStyleThumbnailer is used.
+    */
+    QImage stylePreview(int row, QSize size = QSize());
+
+    /** Sets the @class KoStyleManager of the model. Setting this will populate the styles. It is required that a @param manager is set before using the model.
+      * CAUTION: Populating the style will select the first inserted item. If this model is already set on a view, this might cause the view to emit an item selection changed signal.
+    */
     void setStyleManager(KoStyleManager *manager);
+    /** Sets the @class KoStyleThumbnailer of the model. It is required that a @param thumbnailer is set before using the model. */
     void setStyleThumbnailer(KoStyleThumbnailer *thumbnailer);
 
-public slots:
-    /**
-        Sets the paragraph style that is to be marked as the 'active' one.
-        @param styleId the id from KoParagraphStyle::styleId()
-        @param unchanged if true the icon will display the paragraph style in the text has no local modifications.
-    */
-    void setCurrentParagraphStyle(int styleId, bool unchanged);
-    /**
-        Sets the character style that is to be marked as the 'active' one.
-        @param styleId the id from KoCharacterStyle::styleId()
-        @param unchanged if true the icon will display the character style in the text has no local modifications.
-    */
-    void setCurrentCharacterStyle(int styleId, bool unchanged);
+    /** Specifies which paragraph style is currently the active one (on the current paragraph). This is used in order to properly preview the "As paragraph" virtual character style. */
+    void setCurrentParagraphStyle(int styleId);
 
 private slots:
     void addParagraphStyle(KoParagraphStyle*);
@@ -87,16 +104,13 @@ private:
     KoStyleManager *m_styleManager;
     KoStyleThumbnailer *m_styleThumbnailer;
 
-    int m_currentParagraphStyle;
-    int m_currentCharacterStyle;
-    bool m_pureParagraphStyle;
-    bool m_pureCharacterStyle;
-    bool m_paragraphMode;
+    KoParagraphStyle *m_currentParagraphStyle;
+    KoCharacterStyle *m_defaultCharacterStyle;
+    Type m_modelType;
 
-    QIcon m_paragIcon, m_charIcon;
+    KIcon m_paragIcon, m_charIcon;
 
     QSignalMapper *m_styleMapper;
-    TextShape *m_tmpTextShape;
 };
 
 #endif
diff --git a/plugins/textshape/dialogs/StylesWidget.cpp b/plugins/textshape/dialogs/StylesWidget.cpp
index 4f31a01..33be92e 100644
--- a/plugins/textshape/dialogs/StylesWidget.cpp
+++ b/plugins/textshape/dialogs/StylesWidget.cpp
@@ -21,9 +21,9 @@
 #include "StylesDelegate.h"
 #include "ParagraphGeneral.h"
 #include "CharacterGeneral.h"
+#include <KoStyleThumbnailer.h>
 
 #include <KoStyleManager.h>
-#include <KoStyleThumbnailer.h>
 #include <KoCharacterStyle.h>
 #include <KoParagraphStyle.h>
 
@@ -42,7 +42,7 @@ StylesWidget::StylesWidget(QWidget *parent, bool paragraphMode, Qt::WindowFlags
         : QFrame(parent, f),
         m_styleManager(0),
           m_styleThumbnailer(0),
-        m_stylesModel(new StylesModel(0, paragraphMode)),
+        m_stylesModel(new StylesModel(0, StylesModel::ParagraphStyle)),
         m_stylesDelegate(new StylesDelegate()),
         m_blockSignals(false),
         m_isHovered(false)
@@ -52,7 +52,7 @@ StylesWidget::StylesWidget(QWidget *parent, bool paragraphMode, Qt::WindowFlags
     m_stylesModel->setStyleThumbnailer(m_styleThumbnailer);
     widget.setupUi(this);
     widget.stylesView->setModel(m_stylesModel);
-    widget.stylesView->setItemDelegate(m_stylesDelegate);
+//    widget.stylesView->setItemDelegate(m_stylesDelegate);
 
     if (paragraphMode) {
         connect(widget.stylesView, SIGNAL(clicked(const QModelIndex&)), this, SLOT(applyParagraphStyle()));
@@ -103,7 +103,7 @@ void StylesWidget::setCurrentFormat(const QTextBlockFormat &format)
     }
 
     m_blockSignals = true;
-    m_stylesModel->setCurrentParagraphStyle(id, unchanged);
+//    m_stylesModel->setCurrentParagraphStyle(id, unchanged);
     m_blockSignals = false;
     widget.stylesView->setCurrentIndex(m_stylesModel->indexForParagraphStyle(*usedStyle));
 }
@@ -134,7 +134,7 @@ void StylesWidget::setCurrentFormat(const QTextCharFormat &format)
     }
 
     m_blockSignals = true;
-    m_stylesModel->setCurrentCharacterStyle(id, unchanged);
+//    m_stylesModel->setCurrentCharacterStyle(id, unchanged);
     m_blockSignals = false;
     widget.stylesView->setCurrentIndex(m_stylesModel->indexForCharacterStyle(*usedStyle));
 }
diff --git a/plugins/textshape/dialogs/TableOfContentsStyleModel.cpp b/plugins/textshape/dialogs/TableOfContentsStyleModel.cpp
index 48ee7c3..6884c46 100644
--- a/plugins/textshape/dialogs/TableOfContentsStyleModel.cpp
+++ b/plugins/textshape/dialogs/TableOfContentsStyleModel.cpp
@@ -20,7 +20,7 @@
 #include "TableOfContentsStyleModel.h"
 
 #include "KoStyleManager.h"
-#include "KoStyleThumbnailer.h"
+#include <KoStyleThumbnailer.h>
 #include "KoParagraphStyle.h"
 #include "ToCBibGeneratorInfo.h"
 #include "KoTableOfContentsGeneratorInfo.h"
